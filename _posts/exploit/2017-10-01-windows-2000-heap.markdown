---
layout:		post
title:		实战:分析Windows 2000下堆的分配释放原理
author:		wooy0ung
tags:		
category:  	exploit
---


>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

VC 6.0新建一个工程, 贴入以下代码, 选择release版本

```
#include <windows.h>

int main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp = HeapCreate(0, 0x1000, 0x1000);
	printf("hp addr : 0x%08x\n",hp);
	__asm int 3;

	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19);
	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);

	HeapFree(hp,0,h1);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h5);

	HeapFree(hp,0,h4);
	
	return 0;
}
```

打开OllyDbg, Options->Just-in-time debugging, 按以下设置

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x00.png)

现在, OllyDbg作为默认调试器


### 0x01 堆块申请

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x01.png)

可以到cmd将堆基址0x00360000打印出来了

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x02.png)

程序断在了int 3, 往上看到mov esi, eax

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x03.png)

看esi寄存器的值, 返回来堆基址

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x04.png)

选择"M"观察内存布局, 内存区域中goto 0x00360178

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x05.png)

这里是空表的freelist[0], 指向偏移0x688的一个尾块, goto 0x00360688

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x06.png)

```
# 占用态块首结构
Self Size = 01 30 # 0x130*8=980 bytes
Previous chunk Size = 00 08
Segment Index = 00
Flags = 10
Unused bytes = 00
Tag index(Debug) = 00
```

最后指向freelist[0]构成双向列表


### 0x02 堆块分配

先看看HeapAlloc()的传入参数

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x07.png)

单步到这里, 完成第1次分配

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x08.png)
![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x09.png)

```
# 第1块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求3 bytes
Previous chunk Size = 00 08
Segment Index = 00
Flags = 01
Unused bytes = 0D # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

第2次分配

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0a.png)

```
# 第2块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求5 bytes
Previous chunk Size = 00 02
Segment Index = 00
Flags = 01
Unused bytes = 0B # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

单步到这里, 完成6次分配

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0b.png)
![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0c.png)

```
# 第6块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求24 bytes
Previous chunk Size = 00 04
Segment Index = 00
Flags = 01
Unused bytes = 08 # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

实际分配堆块大小 = [请求字节数/8+1]*8 bytes, 以及8 bytes的头部

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0d.png)

再来看看尾块块首, Size = 0x130-0x2*4-0x4*2=0x120


### 0x02 堆块释放 & 合并

单步下去, 完成前3次释放, 因为h1、h3、h5不相邻, 不会发生合并

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0e.png)

现在产生了2条空闲链表freelist[2]、freelist[4]

![](/assets/img/exploit/2017-10-01-windows-2000-heap/0x0f.png)

继续完成第4次释放, h3、h4、h5相邻发生合并, size=64 bytes, 链入freelist[8]